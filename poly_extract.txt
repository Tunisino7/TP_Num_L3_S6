Poly de TP de physique numÃ©rique,
UE LU3PY126 PAD

12 janvier 2026
Sorbonne UniversitÃ© - L3 Physique

1

Table des matiÃ¨res
Table des matiÃ¨res

3

0 Marches alÃ©atoires
0.1 Nombres alÃ©atoires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.1.1 GÃ©nÃ©rer des nombres alÃ©atoires avec NumPy . . . . . . . . . . . .
0.2 Marches alÃ©atoires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.2.1 Marches alÃ©atoires Ã  pas discrets . . . . . . . . . . . . . . . . . . .
0.2.2 Analyse statistique . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.2.3 Marche alÃ©atoire Ã  pas continus en 2D . . . . . . . . . . . . . . . .
0.3 Annexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.3.1 Approche vectorisÃ©e . . . . . . . . . . . . . . . . . . . . . . . . . .
0.3.2 Calcul de lâ€™Ã©cart-type . . . . . . . . . . . . . . . . . . . . . . . . . .
0.3.3 Marche alÃ©atoire et physique . . . . . . . . . . . . . . . . . . . . .
0.3.3.1 PropriÃ©tÃ©s statistique dâ€™une marche Ã  pas discrets . . . .
0.3.3.2 Marches alÃ©atoires et diffusion . . . . . . . . . . . . . . .

5
5
5
6
6
8
9
11
11
11
12
12
13

1 RÃ©solution numÃ©rique dâ€™Ã©quations diffÃ©rentielles ordinaires - 1Ã¨re partie :
la mÃ©thode dâ€™Euler et rk4
1.1 La mÃ©thode dâ€™Euler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1 SystÃ¨me de n Ã©quations diffÃ©rentielles du premier ordre . . . . . .
1.1.1.1 Fonction deriv() . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1.2 Fonction euler() . . . . . . . . . . . . . . . . . . . . . . . .
1.2 MÃ©thode de Runge-Kutta . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Pour aller plus loin : RÃ©duire le temps de calcul avec numba . . . . . . . .
1.4 Remarque : Avantages de rk4 par rapport aux fonctions odeint et solve_ivp
de scipy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

15
15
17
17
18
19
19
21

2 RÃ©solution numÃ©rique dâ€™Ã©quations diffÃ©rentielles ordinaires - 2Ã¨me partie :
application au pendule chaotique
23
2.1 Ã‰tude du mouvement dâ€™un pendule avec lâ€™approximation des petits angles 23
2.2 Mouvement chaotique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.3 Pour aller plus loin : Diagramme de bifurcation. . . . . . . . . . . . . . . . 24
3 Adsorption de particules sur une surface
3.1 Surface homogÃ¨ne . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1 Conseils pour la mise en place du programme . . . . . . . . . . .
3.1.1.1 La structure de donnÃ©es pour reprÃ©senter les cercles . .
3.1.1.2 Lâ€™organisation du code . . . . . . . . . . . . . . . . . . . .
3.1.2 Analyse des rÃ©sultats . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Surface structurÃ©e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 Mise en place du programme . . . . . . . . . . . . . . . . . . . . .

27
27
28
28
29
30
32
33
3

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

3.2.2 DÃ©pendance de la tempÃ©rature . . . . . . . . . . . . . . . . . . . .
Pour aller plus loin : MAX_TRIES et numba . . . . . . . . . . . . . . . . . .
Annexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.1 numba . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4.2 Liens sur lâ€™empilement compact . . . . . . . . . . . . . . . . . . .

33
34
34
34
35

4 Valeurs propres et vecteurs propres : RÃ©solution de lâ€™Ã©quation de SchrÃ¶dinger par un calcul de diffÃ©rences finies
4.1 La mÃ©thode des diffÃ©rences finies. . . . . . . . . . . . . . . . . . . . . . . .
4.2 Valeurs propres-vecteurs propres. . . . . . . . . . . . . . . . . . . . . . . .
4.3 Mise en Å“uvre numÃ©rique. . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Ã‰tude numÃ©rique. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4.1 Puits carrÃ© infini. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4.2 Potentiel harmonique. . . . . . . . . . . . . . . . . . . . . . . . . .
4.4.3 Double puits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4.4 Pour aller plus loin : Double puits particuliers . . . . . . . . . . . .
4.5 Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

37
38
39
41
41
42
43
43
44
44

3.3
3.4

TP 0
Marches alÃ©atoires
0.1

Nombres alÃ©atoires

Pour simuler informatiquement un processus alÃ©atoire, il est nÃ©cessaire dâ€™utiliser un
gÃ©nÃ©rateur qui fournit une suite de nombres sâ€™approchant le plus possible dâ€™un Â«vraiÂ»
hasard. Par vrai hasard on entend par exemple le fait que la suite produite ne doit pas
Ãªtre pÃ©riodique et que les nombres produits doivent Ãªtre uniformÃ©ment rÃ©partis.
On utilise en pratique des algorithmes qui produisent une suite pÃ©riodique, mais
avec une pÃ©riode trÃ¨s grande : par exemple m = 232 . Un exemple dâ€™algorithme utilisÃ©
pour gÃ©nÃ©rer une suite Xn de nombres est :
Xn+1 = (aXn + c) mod m
oÃ¹ le modulo m dÃ©termine la pÃ©riode maximale de la suite et X0 est la â€œgraineâ€ (ou
â€œseedâ€ en anglais), le premier terme de la suite. Ce gÃ©nÃ©rateur de nombre alÃ©atoires
(random number generator, RNG) sâ€™appelle â€œgÃ©nÃ©rateur congruentiel linÃ©aireâ€ (linear
congruential generator (LCG)) inventÃ© par le mathÃ©maticien amÃ©ricain Derrick Lehmer
en 1948 pour c=0 (Lehmer RNG). On peut tester cet algorithe en calculant Ã  la main la
suite des Xn pour une valeur faible de m :
itÃ©ration
m = 9, a = 4,c=1
m = 9, a = 2,c=0
1.

X0
0
1

X1
1
2

X2
5
4

X3
3
8

X4
4
7

X5
8
5

X6
6
1

X7
7
2

X8
2
4

X9
0
8

X10
1
7

X11
5
5

Â·Â·Â·
Â·Â·Â·
Â·Â·Â·

VÃ©rifiez rapidement ces calculs. Quelle est la pÃ©riodicitÃ© des deux suites obtenues ?

0.1.1

GÃ©nÃ©rer des nombres alÃ©atoires avec NumPy

En python, numpy contient dÃ©jÃ  tout ce quâ€™il faut pour gÃ©nÃ©rer des nombres alÃ©atoires (â€œrandom numbersâ€)
import numpy as np
# On initialise le "random number generator" avec la graine 12345 :
np.random.seed(12345)
for i in range(10):
print(np.random.rand()) # un rÃ©el dans [0,1)
for i in range(10):
print(np.random.random_integers(low=1, high=6)) # un entier dans
,â†’ [1,6]
5

Sorbonne UniversitÃ©
2.

3P126 - TP phys. num.

2025-2026

ExÃ©cutez le code ci-dessus plusieurs fois. Puis, Enlevez lâ€™appel Ã  np.random.seed() et
exÃ©cutez le code modifiÃ© plusieurs fois. Quâ€™est-ce que vous observez ?
Les fonctions np.random.rand() et np.random.random_integers() renvoient la
mÃªme suite de nombres Ã  chaque exÃ©cution si on ne change pas la graine X0 . Essayez
de comprendre pourquoi il est souhaitable et important, en programmation scientifique, que les sÃ©quences de nombres alÃ©atoires ne changent pas dâ€™une exÃ©cution Ã 
lâ€™autre du programme.

En utilisant lâ€™argument size=N ces fonction renvoient N nombres alÃ©atoires sans passer
par une boucle for. Ã€ lâ€™aide de la fonction np.random.rand(), il est facile dâ€™obtenir des
nombres flottants dans lâ€™intervalle que lâ€™on souhaite qui pourront Ãªtre stockÃ©s dans un
tableau numpy. :
N = 10
a = np.random.rand(size=N)
# a contient N flottants alÃ©atoires avec
,â†’ 0 <= a < 1
b = 3.0 * np.random.rand(size=N) + 6.5; # b contient N flottants
,â†’ alÃ©atoires avec 6.5 <= b < 9.5
3.

Ecrivez un code qui simule le lancÃ© de deux dÃ©s Ã  six faces (non truquÃ©s !) jusquâ€™Ã  ce
que lâ€™on obtienne un â€œdouble sixâ€. Utilisez une boucle while.

0.2

Marches alÃ©atoires

Les marches alÃ©atoires sont le point de dÃ©part de nombreuses modÃ©lisations physiques dÃ©crivant le mouvement brownien, la diffusion, les polymÃ¨res, etc. Elles ont Ã©tÃ©
introduites en physique en 1905 par Albert Einstein.

0.2.1

Marches alÃ©atoires Ã  pas discrets

Le modÃ¨le le plus simple dâ€™une marche alÃ©atoire Ã  une dimension est celui dâ€™une particule pouvant se dÃ©placer par pas discrets (Â±1)
qui sâ€™effectuent au hasard Ã  droite ou Ã  gauche
(voir Figure 0.1). La particule part de lâ€™ori- -5 -4 -3 -2 -1 0 1 2 3 4 5
gine (x = 0) et la marche sâ€™arrÃªte au bout
dâ€™un nombre n de pas. La marche est dite Figure 0.1 â€“ Une marche alÃ©atoire
isotrope si la probabilitÃ© dâ€™aller Ã  droite est discrÃ¨te Ã  1D.
la mÃªme p = q = 1/2 que celle dâ€™aller Ã 
gauche.
4.

Comment feriez-vous pour rÃ©aliser un tirage â€œÃ  pile ou faceâ€ ? Le rÃ©sultat du tirage sera
reprÃ©sentÃ© par les nombres entiers relatifs Â±1 ?
Il y a plusieurs chemins qui mÃ¨nent Ã  Rome, surtout en python. Voici quelques
solutions possibles :

TP 0

7

â–· np.random.choice([-1,1], size=N) est une solution simple que vous pouvez
utiliser, voir lâ€™aide dans Spyder sur cette fonction (clique sur la fonction puis
Ctrl+I).
N= 10
a = np.random.choice([-1,1], size=N)
â–· On gÃ©nÃ¨re un ensemble de nombres alÃ©atoires entiers entre zÃ©ro et un inclut,
donc au final des zÃ©ros et des uns, et on les stocke dans un tableau nommÃ© x par
exemple. Ensuite on applique la formule 2*x - 1 dâ€™une faÃ§on vectorielle sur tous
les Ã©lÃ©ments de x, afin dâ€™avoir que des -1 et des 1. Donc pas besoin de faire des
tests pour filtrer des zÃ©ros, grÃ¢ce Ã  cette formule.
x = np.random_integers(0,1, size=N)
a = 2*x -1
â–· np.random.rand() peut Ãªtre utilisÃ© avec un test if dans une boucle :
a = np.empty(N) # on crÃ©e un tableau numpy
for i in range(N):
if np.random.rand() < 0.5 :
a[i] = 1
else:
a[i] = -1
â–· Il est Ã©galement possible dâ€™utiliser x=np.random.rand(N) sans boucle, avec la
formule 2*(x<0.5)-1 qui donne -1 ou +1 alÃ©atoirement, car x<0.5 sera =0 si la
condition est fausse ou =1 si la condition est vraie :
x = np.random.rand(size=N)
a = 2 * (x<0.5) -1
5.

Ã‰crivez un programme qui fait la simulation dâ€™une marche de N pas. La position du
â€œmarcheurâ€ est lâ€™intÃ©grale, ou la somme cumulÃ©e des N pas. CrÃ©ez une boucle sur sur
N pas et stockez la position en fonction du temps. Affichez la position en fonction du
temps, ainsi que la position finaleen utilisant la fonction plot() de matplotlib.
import numpy as np
import matplotlib.pyplot as plt
#np.random.seed(12345)
NPAS = 100
marche = np.empty(NPAS) # un array numpy vide pour stocker la position
,â†’ en fonction du temps
def pile_face():
return ... # Choisissez une approche parmi celles proposÃ©e ci-dessus
marche[0] = 0 # position initiale
for i in range(1,NPAS):
pas = pile_face()
marche[i] = ... # Calculez la somme cumulÃ©e
# Affichage des rÃ©sultats
plt.plot(np.arange(NPAS),marche)

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

# TRES IMPORTANT ! Bien dÃ©finir les axes de tout graphe
plt.title(â€™position finale : %dâ€™ % marche[-1])
plt.xlabel(â€™# pasâ€™)
plt.ylabel(â€™positionâ€™)
Les boucles sont lentes en python et une approche pour accÃ©lÃ©rer le programme est de
le vectoriser. Lâ€™idÃ©e consiste Ã  remplacer une (ou plusieurs) boucle(s) par des calculs sur un
tableau numpy. Par exemple ici, au lieu de choisir une par une les valeurs alÃ©atoires du pas, on
va crÃ©er directement un tableau contenant tous les pas choisis alÃ©atoirement et faire les calculs
directement en utilisant ce tableau. (Voir Annexe 0.3.1)

0.2.2

Analyse statistique

Afin de caractÃ©riser les propriÃ©tÃ©s statistiques de ce modÃ¨le, il est nÃ©cessaire dâ€™effectuer un grand nombre de marches, toutes du mÃªme nombre N de pas.
6.

Modifiez ce programme en dÃ©finissant une fonction marche(npas) qui effectue une
marche alÃ©atoire de npas pas et renvoie la position finale. Utilisez maintenant cette
fonction pour Ã©crire un programme pour effectuer un nombre NMARCHES de marches
de npas pas chacune. Chaque marche est indÃ©pendante de la prÃ©cÃ©dente, et redÃ©marre
donc depuis lâ€™origine. Calculez la moyenne sur toutes ces NMARCHES marches de la
position dâ€™arrivÃ©e du marcheur, ainsi que son Ã©cart type. en utilisant les fonctions
mean() et std() de numpy.
import numpy as np
#np.random.seed(12345)
NPAS = 100
NMARCHES = 1000
arrivee = np.empty(NMARCHES) # array numpy vide pour stocker les
,â†’ NMARCHES positions dâ€™arrivÃ©e
def pile_face(npas):
return ...
def marche(pas):
...
for i in range(NMARCHES):
arrivee[i] = marche(NPAS)
print(â€™<x> = %.2g, ectat-type = %.4gâ€™ %
,â†’ (np.mean(arrivee),np.std(arrivee)))
Dans le cadre de cette Ã©tude, le nombre de positions x demeure peu Ã©levÃ© et donc le stockage en mÃ©moire de toutes les positions dans un tableau numpy avant dâ€™effectuer le calcul
de la moyenne et de lâ€™Ã©cart-type ne pose pas de problÃ¨me. Si a contrario la quantitÃ© de donnÃ©es devient trÃ¨s importante et que seules nous intÃ©ressent la moyenne et lâ€™Ã©cart-type (ou la
valeur quadratique moyenne), il est alors intÃ©ressant dâ€™utiliser leur dÃ©finition pour les calculer
â€œÃ  la volÃ©eâ€, câ€™est-Ã -dire en les mettant Ã  jour Ã  chaque itÃ©ration de la boucle (voir lâ€™annexe 0.3.2).

TP 0
7.

9

FaÃ®tes les mÃªmes simulations pour un nombre de pas variant de n = 50 jusquâ€™Ã  n = 6400
en doublant le nombre de pas Ã  chaque fois : câ€™est-Ã -dire effectuez NMARCHES de n = 50
pas, en calculant les mÃªmes quantitÃ©s statistiques quâ€™au point prÃ©cÃ©dent, puis NMARCHES
de n = 100 pas, etc.... Tracer lâ€™Ã©cart-typeâˆšÏƒ en fonction de n avec trois graphes diffÃ©rents
(sÃ©parÃ©ment) : Ïƒ(n), log(Ïƒ(log(n)) et Ïƒ( n). Expliquer en quoi ces deux derniers plot
permettent de dÃ©terminer la relation entre Ïƒ et n.
import numpy as np
import matplotlib.pyplot as plt
#np.random.seed(12345)
NPAS_LISTE = [50,100,200,400,800,1600,3200,6400 ]
NMARCHES = 1000
arrivee = np.empty(NMARCHES)
sigma = [] # liste vide pour stocker les valeurs de lâ€™Ã©cart-type
def pile_face(npas):
return ...
def marche(pas):
...
return ...
for NPAS in NPAS_LISTE:
for i in range(NMARCHES):
arrivee[i] = marche(NPAS)
sigma.append(np.std(arrivee))
# Affichage, ne pas oublier de dÃ©crire les axes !
plt.plot(NPAS_LISTE,sigma,â€™o-â€™)
...
plt.plot(np.log(NPAS_LISTE),np.log(sigma),â€™o-â€™)
...
plt.plot(np.sqrt(NPAS_LISTE),sigma,â€™o-â€™)
...
Ce rÃ©sultat pouvait Ãªtre prÃ©dit thÃ©oriquement. Une analyse statistique plus complÃ¨te
montrerait que la position dâ€™arrivÃ©e aprÃ¨s n pas est une variable alÃ©atoire qui suit une
distribution de Gauss et donc que la marche alÃ©atoire Ã  pas discret est un modÃ¨le du
processus de diffusion (voir annexe 0.3.3).

0.2.3

Marche alÃ©atoire Ã  pas continus en 2D

Nous avons jusquâ€™Ã  prÃ©sent considÃ©rÃ© des marches alÃ©atoires dont les pas Ã©taient
discrets et uniformÃ©ment distribuÃ©s (pouvant prendre la valeur Â±1 avec une probabilitÃ©
Ã©gale p = 1/2). Bien que trÃ¨s intÃ©ressante pour modÃ©liser des phÃ©nomÃ¨nes physique
(comme le processus de diffusion mentionnÃ© ci-dessus), il ne sâ€™agit que dâ€™un cas particulier. On peut aussi crÃ©er des marches alÃ©atoires dont les pas peuvent prendre des

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

0.6
0.5
0.4
0.3
0.2
0.1
0.5
0.4
0.3
0.2
0.1
-5

0

5

0

5

Figure 0.2 â€“ Distributions pour le pas, f (âˆ†x). En haut Ã  gauche : pas discret de Â±1, en
haut Ã  droite : pas continue avec probabilitÃ© uniforme entre -1 et +1, en bas Ã  gauche :
distribution de Gauss, en bas Ã  droite : distribution de Lorentz.
valeurs distribuÃ©es de faÃ§on continue sur un intervalle donnÃ© en suivant une loi de distribution donnÃ©e f (âˆ†x), voir figure 0.2. Ces diffÃ©rentes lois de probabilitÃ© sont Ã  choisir
en fonction des phÃ©nomÃ¨nes physiques que lâ€™on souhaite modÃ©liser.
On trouve dans numpy des fonctions pour crÃ©er lâ€™ensemble des distributions usuelles,
en particulier la distribution de Gauss () et de Lorentz :
âˆ†x2

Gauss

f (âˆ†x) = âˆš12Ï€ eâˆ’ 2

np.random.randn()

Lorentz

f (âˆ†x) = Ï€1 (âˆ†xâˆ’a)b 2 +b2

np.random.standard_cauchy()

La distribution de Lorentz (ou toute distribution â€œlentementâ€ dÃ©croissante) permet
de crÃ©er de faÃ§on exceptionnelle, ou rare, quelques pas â€œtrÃ¨s grandsâ€ par rapport Ã 
la moyenne des autres (quâ€™on nâ€™observe pas avec les autres marches alÃ©atoires que
nous avons Ã©tudiÃ©es qui dÃ©crivent des mouvements dits browniens). Elles sont aussi
utiles pour modÃ©liser dâ€™autres phÃ©nomÃ¨nes faisant intervenir des fluctuations brusques
et importantes, par exemple dans le domaine de la finance. Ce type de marche est
aussi utilisÃ© pour modÃ©liser le mouvement de prÃ©dateurs explorant un territoire Ã  la
recherches dâ€™une proie 1 ou dâ€™autres stratÃ©gies de recherche dans un espace donnÃ©.
Pour illustrer nous allons rÃ©aliser une marche alÃ©atoire dans un espace bidimensionnel. Chaque pas sera dÃ©terminÃ© par deux nombres alÃ©atoires : un premier distribuÃ©
suivant une dsitribution de Gauss ou de Lorentz pour la longueur du pas et un second
distribuÃ© uniformÃ©ment sur lâ€™intervalle [0, Ï€[ pour la direction (orientation) du pas
8.

Ecrivez un programme qui simule cette marche alÃ©atoire puis qui affiche la trajectoirey(x)
.
1. Viswanathan, G. Fish in LÃ©vy-flight foraging. Nature 465, 1018â€“1019 (2010).
https ://doi.org/10.1038/4651018a

TP 0

11

import numpy as np
import matplotlib.pyplot as plt
#np.random.seed(12345)
NPAS = 6000
x = np.empty(NPAS)
y = np.empty(NPAS)
x[0] = 0
y[0] = 0
for i in range(1,NPAS):
l = ...
# longueur
theta = ... # orientation
x[i] = ...
y[i] = ...
plt.plot(x,y,â€™o-â€™)
ExÃ©cutez votre programme pour des gaussiens, puis pour des pas lorentziens.
Quâ€™observez-vous ?.

0.3

Annexes

0.3.1

Approche vectorisÃ©e

Le code ci-dessous est une vesion vectorisÃ©e de la marche alÃ©atoire. Il prÃ©sente lâ€™avantage
dâ€™Ã©viter la boucle for mais en contrepartie il faut stocker en mÃ©moire tous les NPAS nombres
alÃ©atoires. Lâ€™approche la plus efficace est Ã  apprÃ©cier selon la simulation physique envisagÃ©e. :

NPAS = 100
def pile_face(npas): # retourne npas pas alÃ©atoires
return 2 * np.random.random_integers(0,1, size=npas) -1
pas = pile_face(NPAS)
marche = np.cumsum(pas)

0.3.2

Calcul de lâ€™Ã©cart-type

Pour rappel, lâ€™Ã©cart-type ÏƒX dâ€™une grandeur X est dÃ©finie comme :
N
h
i 1 X
(xi âˆ’ < X >)2
Ïƒ2X = E (X âˆ’ E(X))2 =
N
i=0

oÃ¹ E(X) est lâ€™espÃ©rance de X, câ€™est-Ã -dire la moyenne dâ€™une grandeur X. On pourrait utiliser
cette formule pour calculer lâ€™Ã©cart-type, mais ceci consommerait beaucoup de mÃ©moire vive,
car on devrait garder en mÃ©moire toutes les valeurs xi de X pour calculer la diffÃ©rence entre ces
valeurs et < X >. Comme dÃ©jÃ  pour le calcul dâ€™une moyenne, on peut aussi Ã©viter de garder
tous les xi en mÃ©moire pour le calcul de lâ€™Ã©cart-type. Pour cela, on transforme la formule de
lâ€™Ã©cart-type comme ceci :

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

i
h
Ïƒ2X = E X2 âˆ’ 2 Â· X Â· E(X) + (E(X))2
= E(X2 ) âˆ’ 2 Â· E(X) Â· E(X) + (E(X))2
= E(X2 ) âˆ’ (E(X))2
En plus de la moyenne de X, il suffit alors de calculer en mÃªme temps la moyenne de X2 , ce
qui donne alors :
1
Ïƒ2X =
N

N
X
i=0

ï£«
ï£¬

ï£¬1
x2i âˆ’ ï£¬ï£¬ï£¬ï£­
N

ï£¶2
N
X
ï£·ï£·
xi ï£·ï£·ï£·ï£¸
i=0

Le code ci-dessous gÃ©nÃ¨re une sÃ©rie de N nombres alÃ©atoires et calcule â€œÃ  la volÃ©eâ€
la moyenne et la variance :
import numpy as np
somme = 0
somme_carree = 0
N = 10000
for i in range(N):
x = np.random.rand()
somme += x
somme_carree += x**2
moyenne = somme/N
variance = somme_carree/N - moyenne**2
print(â€™moy : %.3g , var : %.3gâ€™ % (moyenne,variance))

0.3.3

Marche alÃ©atoire et physique

0.3.3.1

PropriÃ©tÃ©s statistique dâ€™une marche Ã  pas discrets

Il est relativement simple de prÃ©dire la loi de variation de la position xn au bout de n pas
dâ€™une marche alÃ©atoire Ã  pas discrets : on peut considÃ©rer que xn est une somme de n variables
alÃ©atoires u qui chacune peuvent prendre la valeur Â±1 avec une probabilitÃ© Ã©gale p = 1/2. La
variable alÃ©atoire u a une valeur moyenne nulle
X
< u >=
pi ui = 1/2 Ã— âˆ’1 + 1/2 Ã— 1 = 0
i

et une variance
Ïƒ2u =< u2 > âˆ’ < u >2 =

X

pi u2i = 1.

i

La position moyenne < xn > aprÃ¨s n pas peut se calculer en utilisant la linÃ©aritÃ© de la
moyenne :
n
n
X
X
< xn > = <
ui > =
< ui > = 0.
i=1

i=1

De la mÃªme faÃ§on, sachant que < xn >= 0 et que les ui sont indÃ©pendants entre eux, on a pour
la variance de x :
n
n
X
X
XX
Ïƒ2n = < x2n > âˆ’ < xn >2 = < (
u i )2 > = <
u2i > + <
ui u j > = nÏƒ2u = n.
i=1

i=1

i

j,i

TP 0

13

On trouve donc que la position moyenne au bout de n pas est nulle, et que son Ã©cart-type, soit en
âˆš
dans
quelque sorte la largeur typique de la distribution, vaut n. Dans le cas de mouvements
âˆš
des espaces Ã  deux ou trois dimensions on peut montrer quâ€™on obtient Ïƒ = dn oÃ¹ d = 1, 2, 3
est la dimension de lâ€™espace.

0.3.3.2

Marches alÃ©atoires et diffusion

Pour faire le lien avec la physique, la marche alÃ©atoire que nous avons Ã©tudiÃ©e est en lien
avec le processus de diffusion. On peut calculer par exemple comment Ã©volue la densitÃ© C(x, t)
de molÃ©cules dâ€™un certain type au cours du temps Ã  partir dâ€™une valeur initiale oÃ¹ toutes les
molÃ©cules sont en x = 0 (soit C(x, 0) = Î´(x)). Lâ€™Ã©quation de la diffusion, valable Ã  une Ã©chelle
macroscopique, est donnÃ©e par :
dC
d2 C
=D 2
dt
dx
oÃ¹ la constante D est le coefficient de diffusion. Ce coefficient D est reliÃ© Ã  la marche alÃ©atoire Ã 
pas discrets par la relation suivante : D = â„“2 /2Ï„ oÃ¹ â„“ est la longueur de chaque pas et Ï„ est la
durÃ©e moyenne entre deux pas. La solution pour une injection ponctuelle en x = 0 de toutes les
molÃ©cules est donnÃ©e par :
2
1
C(x, t) = âˆš
eâˆ’x /4Dt ,
4Ï€Dt
et est Ã©quivalente Ã  la distribution limite que lâ€™on obtient pour la marche alÃ©atoire Ã  grand
nombre n de pas discrets en faisant la correspondance t = nÏ„, â„“ = 1 et donc Dt = n/2. Lâ€™Ã©carttype de cette distribution est souvent appelÃ©e la distance caractÃ©ristique de diffusion. Quelle est
lâ€™Ã©volution de cette distance en fonction du temps ? Comparez au cas du mouvement rectiligne
uniforme.
La marche alÃ©atoire peut Ãªtre utilisÃ©e pour modÃ©liser un grand nombre de phÃ©nomÃ¨nes physiques, par exemple :

â–· On sâ€™intÃ©resse Ã  une goutte de lait dÃ©posÃ©e dans une tasse de cafÃ©. Si on connaÃ®t le temps t0
pour que le lait se rÃ©partisse (diffuse) dans une tasse de taille donnÃ©e, combien faudrait-il
pour que le lait diffuse dans une tasse 2 fois plus grande ?

â–· Le mouvement dâ€™une molÃ©cule de dioxyde de carbone dans un alvÃ©ole pulmonaire est
aussi un mouvement diffusif : lâ€™alvÃ©ole peut Ãªtre considÃ©rÃ© comme une sphÃ¨re de rayon
R = 100Âµm et le coefficient de diffusion dâ€™une molÃ©cule de CO2 dans lâ€™air est D =
0, 14cm2 sâˆ’1 . Quel est le temps caractÃ©ristique pour quâ€™une molÃ©cule de dioxyde de carbone
se dÃ©place de la pÃ©riphÃ©rie vers le centre de lâ€™alvÃ©ole pulmonaire ?

TP 1
RÃ©solution numÃ©rique dâ€™Ã©quations
diffÃ©rentielles ordinaires - 1Ã¨re partie :
la mÃ©thode dâ€™Euler et rk4
1.1

La mÃ©thode dâ€™Euler

Une Ã©quation diffÃ©rentielle du premier ordre satisfaite par une fonction y(t) est de
la forme,


dy(t)
= f y(t), t
(1.1)
dt
oÃ¹ f est une fonction connue qui dÃ©pend du problÃ¨me considÃ©rÃ©. La mÃ©thode la plus
simple pour rÃ©soudre numÃ©riquement une telle Ã©quation est la mÃ©thode dâ€™Euler, figure
1.1 . La fonction y est calculÃ©e aux points tk = kâˆ†t avec k entier, sÃ©parÃ©s par un petit
intervalle âˆ†t. La valeur de y au point tk+1 = tk + âˆ†t est obtenue Ã  partir de la valeur au
point tk par la formule,

y(tk+1 ) = y(tk ) + f y(tk ), tk ) Ã— âˆ†t
(1.2)
A partir de la donnÃ©e dâ€™une condition initiale y(t0 ), on peut ainsi calculer de proche en
proche y pour des valeurs successives de t. Les questions 1-3 proposent des applications
de cette mÃ©thode Ã  des cas trÃ¨s simples.
1.

Lâ€™Ã©volution dans le temps de la densitÃ© x(t) dâ€™un Ã©lÃ©ment radioactif X subissant une
rÃ©action de dÃ©sintÃ©gration X â†’ Y obÃ©it Ã  lâ€™Ã©quation diffÃ©rentielle
dx
= âˆ’kx
dt

(1.3)

oÃ¹ k est le taux de dÃ©sintÃ©gration. Ã‰crire un petit programme qui calcule par la mÃ©thode
dâ€™Euler et enregistre x pour des valeurs de t entre 0 et Tmax. On prendra k = 1 et vous
fixerez Tmax, âˆ†t et x(0). Tracer x(t) et comparer avec la solution analytique de lâ€™Ã©quation
1.3. La formule de la solution analytique est Ã  trouver par soi-mÃªme sur une feuille, car
câ€™est trÃ¨s simple.
Python en pratique : Interdiction dâ€™utiliser la bibliothÃ¨que scipy ici. Pas de fonction
Ã  Ã©crire pour lâ€™instant. Les bibliothÃ¨ques autorisÃ©es : matplotlib et numpy uniquement
. On dÃ©finit deux variables : la densitÃ© x et la vitesse du changement de la densitÃ©
v = âˆ’kx, toutes les deux Ã  lâ€™instant t, donc juste des scalaires pas des listes ou des
tableaux. De plus, on utilise des tableaux de numpy pour enregistrer dans la mÃ©moire
vive les points du temps t et la densitÃ© x. Ces tableaux sont ensuite utilisÃ©s pour faire
15

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

ğ‘¦ğ‘¦
ğ‘¦ğ‘¦(ğ‘¡ğ‘¡ğ‘˜ğ‘˜+1 )
ğ‘¦ğ‘¦(ğ‘¡ğ‘¡ğ‘˜ğ‘˜ )

âˆ†ğ‘¡ğ‘¡

ğ‘¡ğ‘¡ğ‘˜ğ‘˜

ğ‘¡ğ‘¡ğ‘˜ğ‘˜+1

Figure 1.1 â€“ SchÃ©ma mÃ©thode dâ€™Euler.

ğ‘¡ğ‘¡

le graphe x(t) sous matplotlib. Pour une meilleure vitesse de calcul, il est toujours
prÃ©fÃ©rable dâ€™utiliser des tableaux numpy Ã  la place des listes python, car ils sont plus
proches des tableaux en C, donc plus efficaces dans la gestion de la mÃ©moire vive.
Surtout, on peut ensuite accÃ©lÃ©rer le code encore plus avec la bibliothÃ¨que numba qui
marche uniquement sur les tableaux numpy et pas sur les listes python. Les fonctions
numpy Ã  utiliser : empty, arange, linspace (rien dâ€™autre ! surtout pas np.append(), voir
cours-TD). Comparer les fonctions numpy : arange vs linspace. VÃ©rifier notamment
que linspace donne bien un espacement de âˆ†t entre chaque point du temps t. Fonctions
matplotlib Ã  utiliser : plot, xlabel, ylabel, title, legend, savefig, show. Pour lâ€™affichage de
la solution analytique utiliser numpy pour la ou les fonctions nÃ©cessaires pour calculer
les valeurs x(t) pour tous les points du temps t utilisÃ©s pour la solution numÃ©rique. Ces
valeurs ainsi que la diffÃ©rence par rapport Ã  la solution numÃ©rique seront enregistrer
dans deux nouveaux tableaux. Il faudra fournir deux graphes : un premier avec la
superposition de la solution analytique et la solution numÃ©rique et un deuxiÃ¨me avec
la diffÃ©rence des deux.
2.

Supposons maintenant que lâ€™Ã©lÃ©ment Y, dont la densitÃ© est notÃ©e y(t), se dÃ©sintÃ¨gre en
un Ã©lÃ©ment Z avec le taux k2 . On a alors,
dx
= âˆ’kx
dt
dy
= kx âˆ’ k2 y
dt

(1.4)

Ã‰crire un programme analogue au prÃ©cÃ©dent qui calcule et enregistre x(t) et y(t) de t = 0
Ã  Tmax. On prendra k2 = 0.1k, x(0) = 1 et y(0) = 0. Tracer x(t) et y(t).
3.

Lâ€™Ã©volution dâ€™un oscillateur harmonique est dÃ©crite par une Ã©quation du second ordre
d2 x
= âˆ’Ï‰20 x
dt2

(1.5)

Une Ã©quation diffÃ©rentielle du second ordre peut Ãªtre Ã©crite sous forme de deux Ã©quations du premier ordre. Ã‰crire ces deux Ã©quations et Ã©crire un programme calculant

TP 1

17

x(t) avec la mÃ©thode dâ€™Euler. Vous fixerez les paramÃ¨tres et les conditions initiales.
Essayer plusieurs pas de temps âˆ†t, quâ€™est-ce que vous observez sur un grand nombre
de pÃ©riodes ?
De maniÃ¨re gÃ©nÃ©rale, une Ã©quation diffÃ©rentielle dâ€™ordre supÃ©rieur Ã  un peut Ãªtre
transformÃ©e en un systÃ¨me dâ€™Ã©quations du premier ordre.

1.1.1

SystÃ¨me de n Ã©quations diffÃ©rentielles du premier ordre

Le but des questions suivantes est de construire une fonction euler qui implÃ©mente
lâ€™algorithme dâ€™Euler sur un pas (un seul !) et qui puisse Ãªtre utilisÃ©e sans modification
dans tout programme nÃ©cessitant de rÃ©soudre un systÃ¨me dâ€™Ã©quations diffÃ©rentielles.
Pour un ensemble de n Ã©quations diffÃ©rentielles du premier ordre satisfaites par n
fonction yi (t) avec i = 0, 1, .., n âˆ’ 1,


dyi (t)
= fi {y j (t)}, t ,
(1.6)
dt
lâ€™algorithme dâ€™Euler pour le calcul des yi au point t + âˆ†t Ã  partir des valeurs en t peut
Ãªtre dÃ©coupÃ© en deux Ã©tapes :
â€²
1. le  calcul de
 la dÃ©rivÃ©e de chaque fonction yi au point t, donnÃ©e par yi (t) =
fi {y j (t)}, t .
2. le calcul des yi au point t + dt avec la formule yi (t + âˆ†t) = yi (t) + yâ€²i (t) Ã— âˆ†t .
Les valeurs des fonctions yi au point t sont stockÃ©es dans un tableau numpy y de taille
n. Pour lâ€™oscillateur harmonique oÃ¹ on cherche Ã  avoir sa position x(t) et sa vitesse v(t),
il y a deux Ã©quations diffÃ©rentielles du permier ordre, donc n = 2 et les deux cases du
tableau numpy y reprÃ©sentent respectivement la position et la vitesse de lâ€™osciallateur
harmonique au temps t. Pour enregistrer toutes les positions et vitesses sur la durÃ©e de
la simulation (de zÃ©ro Ã  tmax ), on doit crÃ©er encore deux tableaux numpy, xTab et vTab,
avec autant de cases quâ€™on fait de pas de temps âˆ†t.
1.1.1.1

Fonction deriv()

La premiÃ¨re Ã©tape est effectuÃ©e par une fonction deriv() :
deriv() fournit les n dÃ©rivÃ©es des n variables stockÃ©es dans le tableau y.
â–· Corps de la fonction : Câ€™est ici quâ€™on met la physique, i.e. les n Ã©quations diffÃ©rentielles du premier ordre. Soit avec une ligne de code par variable, soit avec une
boucle, si câ€™est possible.
â–· EntrÃ©es :
1. t - temps actuel (Ã  mettre toujours, mÃªme si on nâ€™en a pas besoin toujours,
afin de garder une liste de paramÃ¨tres universelle)
2. y - tableau numpy de taille n pour les variables au temps t
3. params - paramÃ¨tre(s) nÃ©cessaires pour le calcul (optionnel)
â–· Sorties :
1. dy - tableau numpy de taille n pour les dÃ©rivÃ©es au temps
Voici la base de la fonction deriv() :
def deriv(t, y, params):
dy = np.zeros(y.size)
corps de la fonction
return dy

Sorbonne UniversitÃ©
1.1.1.2

3P126 - TP phys. num.

2025-2026

Fonction euler()

La deuxiÃ¨me Ã©tape est effectuÃ©e par une fonction euler :
But : A partir des valeurs des n variables au temps t, calculer leurs valeurs au temps
t+dt (un pas de temps uniquement !) avec la mÃ©thode dâ€™Euler
â–· Corps de la fonction : calcul vectoriel avec numpy, deux lignes de code, pas besoin
de boucle
â–· EntrÃ©es :
1. t - temps actuel
2. dt - pas de temps
3. y - tableau numpy de taille n pour les variables au temps t
4. deriv - nom de la fonction qui fournit les n dÃ©rivÃ©es des n variables qui sont
dans y
5. params - paramÃ¨tre(s) nÃ©cessaires pour le calcul (optionnel)
â–· Sorties :
1. y - valeurs des n variables au temps t+dt
Voici la base de la fonction euler() :
def euler(t, dt, y, deriv, params):
corps de la fonction
return y
4.

Ã‰crire la fonction deriv dans le cas de lâ€™oscillateur harmonique. La valeur du paramÃ¨tre Ï‰0 peut Ãªtre passÃ©e Ã  la fonction via le dernier argument params. Rappel : Pour
lâ€™oscillateur harmonique oÃ¹ on cherche Ã  avoir sa position x(t) et sa vitesse v(t), il y
a deux Ã©quations diffÃ©rentielles du permier ordre, donc n = 2 et les deux cases du
tableau numpy y reprÃ©sentent respectivement la position et la vitesse de lâ€™osciallateur
harmonique au temps t.

5.

Ã‰crire la fonction euler qui reÃ§oit en entrÃ©e les yi (t) dans le tableau y, ainsi que les
valeurs de t et âˆ†t, calcule les yi (t + âˆ†t) et les stocke dans le mÃªme tableau y Ã  la place des
yi (t). Il faudra dans cette fonction appeler la fonction deriv pour avoir le tableau avec
les yâ€²i (t). Inclure les fonctions deriv et euler dans un programme complet permettant
de calculer et afficher x(t) et v(t) comme avant pour lâ€™oscillateur harmonique. VÃ©rifier
que les rÃ©sultats sont identiques. Rappel : Pour enregistrer toutes les positions et vitesses
sur la durÃ©e de la simulation (de zÃ©ro Ã  tmax ), on doit crÃ©er encore deux tableaux numpy,
xTab et vTab, avec autant de cases quâ€™on fait de pas de temps âˆ†t.

6.

Ã‰crire un programme utilisant la fonction euler pour calculer numÃ©riquement la trajectoire dans le plan x âˆ’ y dâ€™une particule de masse m et charge q dans des champs
â†’
âˆ’
â†’
âˆ’
âˆ’
âˆ’u . On rappelle que lâ€™Ã©quation
Ã©lectrique et magnÃ©tique uniformes, E = E â†’
ux et B = B â†’
z
du mouvement est
âˆ’v
â†’
âˆ’ âˆ’ â†’
âˆ’
dâ†’
= q E +â†’
v Ã—B
(1.7)
m
dt
Les unitÃ©s sont choisies de telle sorte que q/m = E = B = 1. Quel est le nombre n
dâ€™Ã©quations diffÃ©rentielles ? Ã‰crire ces Ã©quations et la fonction deriv correspondante.
Afficher et commenter la trajectoire dans le plan x âˆ’ y.

TP 1

19

ğ‘¦ğ‘¦(ğ‘¡ğ‘¡ + âˆ†ğ‘¡ğ‘¡)
ğ‘¦ğ‘¦ğ‘ğ‘

ğ‘¦ğ‘¦(ğ‘¡ğ‘¡)
ğ‘¡ğ‘¡

1.2

ğ‘¡ğ‘¡ + âˆ†ğ‘¡ğ‘¡/2

ğ‘¡ğ‘¡ + âˆ†ğ‘¡ğ‘¡

Figure 1.2 â€“ SchÃ©ma mÃ©thode RK2

MÃ©thode de Runge-Kutta

Pour calculer y(t + âˆ†t) Ã  partir de y(t), les mÃ©thodes de type Runge-Kutta estiment
la valeur de la dÃ©rivÃ©e yâ€² au milieu de lâ€™intervalle entre les points t et t + âˆ†t. La version
la plus simple pour rÃ©soudre lâ€™Ã©quation 1.1 procÃ¨de ainsi (voir figure 1.2) :
d1 = f (y(t), t)
yp = y(t) + d1 Ã— âˆ†t/2
d2 = f (yp , t + âˆ†t/2)
y(t + âˆ†t) = y + d2 Ã— âˆ†t

(1.8)

Cette mÃ©thode sâ€™appelle Runge-Kutta dâ€™ordre 2 car on peut montrer que les erreurs
sont dâ€™ordre (âˆ†t)3 .
La mÃ©thode la plus couramment utilisÃ©e est Runge-Kutta dâ€™ordre 4 (les erreurs sont
dâ€™ordres (âˆ†t)5 ) qui utilise 4 Ã©valuations de la dÃ©rivÃ©e. La fonction est donnÃ©e dans
le fichier rk4.py (voir sur moodle) et vous pouvez lâ€™utiliser directement en la copiant
dans votre programme. Alternativement, vous pouvez aussi lâ€™importer avec from rk4
import rk4, il faut juste mettre le fichier rk4.py dans le mÃªme dossier que votre code.
2

7.

RÃ©soudre lâ€™Ã©quation ddt2x = âˆ’Ï‰20 x en utilisant la fonction euler avec âˆ†t = 0.01s. Tracer
x(t) âˆ’ xth (t) oÃ¹ x(t) est la solution numÃ©rique et xth (t) est la solution analytique exacte.
Que constatez-vous ? Diminuer le âˆ†t. Le problÃ¨me est-il rÃ©solu ?

8.

Refaire la question prÃ©cÃ©dente en utilisant Ã  prÃ©sent la fonction fournie rk4. Pour cela il
suffit dâ€™appeler la fonction rk4 au lieu dâ€™appeler la fonction euler. Que constatez-vous ?

1.3

Pour aller plus loin : RÃ©duire le temps de calcul avec
numba

Voir aussi les exercices de TD sur numba sur moodle, il sâ€™agit dâ€™un tutoriel pour apprendre
Ã  utiliser numba.
Python en tant que langage interprÃ©tÃ© nâ€™est pas trÃ¨s rapide pour exÃ©cuter des
boucles, car chaque ligne de code doit dâ€™abord Ãªtre interprÃ©tÃ©e (=traduit en langage
machine) avant dâ€™Ãªtre exÃ©cutÃ©e, mÃªme quand câ€™est toujours la mÃªme ligne de code dans
une boucle. Il existe des langages compilÃ©s qui nâ€™ont pas ce dÃ©faut, comme le C/C++
ou le Fortran, ou encore des langages qui ont un compilateur Ã  la volÃ©e ("just-in-time"

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

(jit) compiler en anglais) comme le nouveau langage Julia, qui ressemble beaucoup au
python tout en sâ€™Ã©xecutant Ã  la vitesse du C.
Mais il existe heureusement une bibliothÃ¨que en python qui ajoute cette fonctionnalitÃ© du jit-compiler : numba (www.numba.org)
Numba sâ€™utilise trÃ¨s facilement, tant quâ€™on respecte certaines rÃ¨gles :
1. Utiliser uniquement des tableaux numpy et non des listes ou autres objets python,
qui sont plus difficile Ã  traduire par numba.
2. Ne pas utiliser des variables globales pour les fonctions accÃ©lÃ©rÃ©es par numba,
Ã  moins quâ€™il ne sâ€™agisse de constantes qui ne changent pas lors de lâ€™exÃ©cution
du programme. Numba considÃ¨re les variables globales comme des constantes,
mÃªme si on change la valeur dâ€™une variable globale dans une fonction ou le code
principal hors numba. Si on souhaite par exemple exÃ©cuter une fonction accÃ©lÃ©rÃ©e
par numba plusieurs fois et changer une variable globale entre chaque exÃ©cution
(ex : paramÃ¨tre physique comme la tempÃ©rature), cela ne marche pas, numba
conserve la valeur que cette variable avait lors du premier appel Ã  la fonction
(= le moment oÃ¹ la fonction est compilÃ©e par numba). Il faut mettre alors cette
variable en tant quâ€™argument dans la fonction.
3. Ne pas utiliser dtype=int lors de la crÃ©ation dâ€™un tableau numpy, car le type int
est une classe de python et non de numpy, donc pas supportÃ© par numba ! Il faut
utiliser un type de numpy, comme : dtype=np.float64 (pour les valeurs rÃ©elles)
ou dtype=np.int32 (pour les valeurs entiÃ¨res).
Il suffit ensuite dâ€™importer numba avec
from numba import jit
puis dâ€™ajouter lâ€™instruction
@jit(nopython=True)
avant chaque dÃ©claration de fonction qui doit Ãªtre accÃ©lÃ©rÃ©e par numba. Alternativement on peut mettre aussi
from numba import njit
avec le raccourci @njit avant chaque dÃ©claration de fonction, comme ceci :
from numba import njit
@njit
def fonction(x, y):
Il faut faire attention de mettre cette instruction (@njit ou @jit(nopython=True))
aussi sur toutes les sous-fonctions quâ€™on a Ã©crites soi-mÃªme et quâ€™une fonction accÃ©lÃ©rÃ©e
par numba pourrait appeler.
9.

Enregistrer votre programme prÃ©cÃ©dent qui utilise rk4 sous un nouveau nom et modifier le pour pouvoir utiliser numba. Pour cela il faut mettre la boucle sur le temps qui
appelle rk4 dans une nouvelle fonction, afin de pouvoir accÃ©lÃ©rer cette fonction avec
numba. Toutes les sous-fonctions quâ€™appelle cette fonction doivent Ã©galement Ãªtre accÃ©lÃ©rÃ©es avec numba, i.e. on doit ajouter le raccourci @njit devant cette nouvelle fonction
et devant les fonctions rk4 et deriv. rk4 doit alors Ãªtre copiÃ© directement dans votre
code. Comparer le temps dâ€™exÃ©cution de votre programme accÃ©lÃ©rÃ© par numba avec
celui de votre programme sans numba. Pour cela vous pouvez utiliser la bibliothÃ¨que
time de python : il suffit dâ€™enregistrer le temps au dÃ©marrage et Ã  la fin avec :

TP 1

21

start = time.time()
end = time.time()
Choisir un nombre dâ€™itÃ©rations suffisamment grand pour pouvoir mesurer des diffÃ©rences entre les deux versions de votre code (avec et sans numba). Astuce : pour
convertir un code optimisÃ© avec numba en code standard sans numba, il suffit simplement de commenter la ligne avec @njit => #@njit

1.4

Remarque : Avantages de rk4 par rapport aux
fonctions odeint et solve_ivp de scipy

Cette sous-section ne contient pas de question et nâ€™est pas un prÃ©requis pour la suite, il sâ€™agit
juste de mieux comprendre pourquoi lâ€™utilisation de rk4 peut Ãªtre avantageuse par rapport aux
fonctions dÃ©jÃ  fournies par scipy. Donc si vous nâ€™avez plus le temps, vous pouvez lire cette partie
plus tard.
Alternativement Ã  la fonction rk4, on peut aussi utiliser odeint (obsolÃ¨te normalement) ou solve_ivp (nouvelle fonction qui remplace odeint) de scipy. Voici un example
dâ€™utilisation des deux fonctions :
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.integrate import solve_ivp
def deriv1(y,t,omega):
dy = np.zeros(2)
dy[0] = y[1]
dy[1] = -omega**2 * y[0]
return dy
# argument order is different for solve_ivp()
def deriv2(t,y,omega):
dy = np.zeros(2)
dy[0] = y[1]
dy[1] = -omega**2 * y[0]
return dy
t_max = 10
N_pas = 100
time_vec = np.linspace(0, t_max, N_pas)
yinit = (1,0)
omega = 1
result = odeint(deriv1, yinit, time_vec, args=(omega,))
plt.plot(time_vec, result, â€™-oâ€™)
plt.show()
result2 = solve_ivp(deriv2, (0,t_max), yinit, args=(omega,),
,â†’ t_eval=time_vec, rtol=1e-9)
plt.plot(result2.t, result2.y[0], â€™-oâ€™)

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

plt.plot(result2.t, result2.y[1], â€™-oâ€™)
plt.show()
Comme ces deux fonctions sont des boites noires et sont relativement difficiles
Ã  utiliser, car dÃ©jÃ  trÃ¨s avancÃ©es (surtout solve_ivp), nous recommandons dâ€™utiliser
plutÃ´t la fonction rk4 fournie ici, Ã  moins que vous ayez des cas trÃ¨s difficiles pour
lâ€™algorithme RK4 (ce qui est relativement rare) qui auraient besoin dâ€™un pas de temps
adaptatif, comme câ€™est implÃ©mentÃ© dans solve_ivp.
La fonction rk4 a aussi dâ€™autres avantages du fait quâ€™elle ne fait quâ€™un seul pas de
temps et non tous les pas pour un temps de simulation donnÃ© :
1. Comme pour odeint ou solve_ivp, la fonction rk4 nâ€™a pas besoin dâ€™Ãªtre modifiÃ©e
en fonction du problÃ¨me de physique, ce qui Ã©vite dâ€™y introduire des erreurs,
surtout si on lâ€™importe avec from rk4 import rk4
2. On peut choisir combien de points sont enregistrÃ©s dans la mÃ©moire, car souvent
on essaye dâ€™avoir un pas de temps trÃ¨s fin, sans pour autant vouloir produire des
millions points (bonjour les plots !). Câ€™est possible aussi avec solve_ivp via t_eval.
3. Si jamais on souhaite arrÃªter lâ€™intÃ©gration numÃ©rique avant t=tmax, par exemple
parce que le vaisseau spatial est tombÃ© sur la terre, câ€™est faisable avec un simple
test if dans la boucle sur le temps. Autre cas de figure : le pendule oÃ¹ on limite
lâ€™angle entre -180 et +180 avec des tests if dans la boucle sur le temps, mÃªme si ici
on pourrait filtrer les rÃ©sultats en "post-processing" aprÃ¨s la boucle sur le temps.
Lâ€™exemple du diagramme de bifurcation obtenu Ã  partir du pendule chaotique
montre une autre application pour ne pas enregistrer tous les points et de faire la
correction -180/180 en mÃªme temps.
4. Cela permet aussi dâ€™Ã©changer facilement lâ€™algorithme, il suffit simplement de
changer le nom de la fonction dans le programme sans toucher au reste.
5. La fonction rk4 a montrÃ© sa robustesse pendant des annÃ©es en L3 physique numÃ©rique Ã  Sorbonne UniversitÃ© dans sa version en C. Le seul hic sous python est la
performance quâ€™il faut rattraper via numba pour sâ€™approcher des performances
de odeint ou solve_ivp.

TP 2
RÃ©solution numÃ©rique dâ€™Ã©quations
diffÃ©rentielles ordinaires - 2Ã¨me partie :
application au pendule chaotique

2.1

Ã‰tude du mouvement dâ€™un pendule avec
lâ€™approximation des petits angles

On considÃ¨re le pendule simple de la figure prÃ©cÃ©dente, dont lâ€™Ã©quation du mouvement libre sâ€™Ã©crit :
d2 Î¸
dÎ¸
+q
+ â„¦2 sin Î¸ = 0
2
dt
dt

d2 Î¸
dÎ¸
+q
+ â„¦2 Î¸ = 0
2
dt
dt
p
oÃ¹ Î¸ est lâ€™angle que fait le pendule par rapport Ã  la verticale, â„¦ = g/l est la
pulsation propre et q est le terme de frottement fluide. On utilisera par commoditÃ© la
valeur suivante : â„¦ = 1rad.sâˆ’1 .
1.

avec sin Î¸ â‰ƒ Î¸

â†’

RÃ©solvez cette Ã©quation linÃ©arisÃ©e ( ddtÎ¸2 + q dÎ¸
+ â„¦2 Î¸ = 0) avec la mÃ©thode RK4 pour
dt
diffÃ©rentes valeurs de lâ€™amortissement : q = 1, q = 2, q = 5 sâˆ’1 et tracez sur un mÃªme
graphe lâ€™Ã©volution de Î¸(t) dans ces rÃ©gimes respectivement pseudo-pÃ©riodique, critique
et apÃ©riodique. On prendra comme conditions initiales Î¸(t = 0) = 10â—¦ (Ã  convertir en
radian) et dÎ¸
(t = 0) = 0 et un pas de temps dt = 0.05s pour t allant de 0 Ã  20s. Il est
dt
utile ici de mettre la boucle sur le temps qui calcule Î¸(t) dans une fonction avec comme
paramÃ¨tre la valeur de lâ€™amortissement q. Cette fonction devra renvoyer deux tableaux
numpy : celui qui contient les valeurs du temps t et celui qui contient les valeurs de
Î¸(t).
2

23

Sorbonne UniversitÃ©

2.

3P126 - TP phys. num.

2025-2026

On ajoute maintenant une force dâ€™excitation au pendule de sorte que lâ€™Ã©quation du
mouvement sâ€™Ã©crive :
d2 Î¸
dÎ¸
+q
+ â„¦2 Î¸ = Fe sin(â„¦e t).
2
dt
dt
RÃ©solvez cette nouvelle Ã©quation avec la mÃ©thode RK4 pour une force excitatrice dâ€™intensitÃ© Fe = 1rad.sâˆ’2 et de pulsation â„¦e = 2â„¦/3. Tracez sur un mÃªme graphe la trajec) pour le pendule libre (q = 0 et Fe = 0) , amorti
toire dans lâ€™espace des phase (Î¸, dÎ¸
dt
(q=1 et Fe = 0), et amorti avec excitation (q=1 et Fe = 1). On prendra toujours comme
conditions initiales Î¸(t = 0) = 10â—¦ (Ã  convertir en radian) et dÎ¸
(t = 0) = 0. Commentez
dt
la forme des trajectoires que vous observez.

2.2

Mouvement chaotique

Lorsque lâ€™on ne fait plus lâ€™hypothÃ¨se des petits angles (sin Î¸ â‰ƒ Î¸), on obtient une
Ã©quation diffÃ©rentielle dâ€™ordre 2 qui nâ€™est pas linÃ©aire :
dÎ¸
d2 Î¸
+q
+ â„¦2 sin Î¸ = Fe sin(â„¦e t).
2
dt
dt
Pour certaines valeurs des paramÃ¨tres physiques, le comportement du pendule
sera chaotique. Afin dâ€™illustrer ce comportement, on se placera dans les conditions
(t = 0) = 0,
suivantes : Î¸(t = 0) = 10â—¦ (Ã  convertir en radian par votre script python) et dÎ¸
dt
â„¦e = 2â„¦/3, q = 0.5sâˆ’1 .
3.

RÃ©solvez lâ€™Ã©quation du mouvement non-linÃ©aire avec la mÃ©thode RK4 pour les valeurs
suivantes de lâ€™amplitude dâ€™excitation Fe = {1.4, 1.44, 1.465, 1.5} rad.sâˆ’2 et tracez Î¸(t)
sur un temps de 100s (choisir le nombre de plots nÃ©cessaires pour bien distinguer le
comportement). Ajouter deux tests if dans la boucle aprÃ¨s lâ€™appel Ã  rk4 pour maintenir lâ€™angle Î¸ dans lâ€™intervalle [âˆ’Ï€; Ï€]. Que constatez-vous au sujet de la pÃ©riode du
pendule ? (attention, pÃ©riodique,sinusoÃ¯dal...)

4.

Dans le cas Fe = 1.5 rad.sâˆ’2 , calculez lâ€™Ã©volution de Î¸(t) pour deux conditions initiales
trÃ¨s proches lâ€™une de lâ€™autre : Î¸(t = 0) = 10â—¦ et Î¸(t = 0) = 9.999â—¦ . Tracez les deux
trajectoires sur un mÃªme plot. Au bout de combien temps est-ce quâ€™un Ã©cart entre les
deux courbes devient visible ? On voudrait maintenant quantifier comment et avec
quelle la vitesse cet Ã©cart croit. On essaye de vÃ©rifier une croissance exponentielle,
câ€™est-Ã -dire la valeur absolue de cet Ã©cart croit comme eÎ»t oÃ¹ Î» est Â« lâ€™exposant de
Lyapounov Â» qui caractÃ©rise la vitesse Ã  laquelle deux systÃ¨mes quasiment identiques
divergent. Essayer de dÃ©terminer lâ€™exposant de Lyapounov en traÃ§ant le logarithme de
cet Ã©cart absolu :
plt.plot(tValues, np.log(np.abs(theta2 - theta1)))
Puis en y superposant une droite Ã  la main, vÃ©rifiant ainsi quâ€™il sâ€™agit dâ€™une croissance exponentielle. La pente de cette droite est la valeur de lâ€™exposant de Lyapounov
Î». Quâ€™en conclure sur vos capacitÃ©s de prÃ©diction de lâ€™Ã©tat futur du systÃ¨me ?

2.3

Pour aller plus loin : Diagramme de bifurcation.

Afin de mettre en Ã©vidence la transition du systÃ¨me vers le rÃ©gime chaotique, on
oÃ¹ n est un
peut calculer lâ€™Ã©tat du systÃ¨me uniquement Ã  des instants tn tels que tn = 2Ï€n
â„¦e
entier, ce qui veut dire quâ€™on lâ€™observe en phase avec la frÃ©quence excitatrice. Comme
dans le cas oÃ¹ on observe un mouvement avec un stroboscope, si le pendule est dans un

TP 2

25

Figure 2.1 â€“ Diagramme de bifurcation
rÃ©gime stationnaire et oscille Ã  la frÃ©quence dâ€™excitation, alors les valeurs de Î¸n que lâ€™on
calcule ont la mÃªme valeur, câ€™est comme si on avait figÃ© le mouvement. En faisant varier
la valeur de la force dâ€™excitation, vous pourrez Ã©tudier les changements de rÃ©gime du
pendule.
5.

Pour tracer le diagramme de bifurcation, il faut faire Ã©voluer le systÃ¨me suffisamment
longtemps pour Ã©liminer le rÃ©gime transitoire, et afficher par exemple 50 ou 100 valeurs
de Î¸ pour des temps multiples entielstinliners de la pÃ©riode dâ€™excitation. On choisira
2Ï€
un Î´t adaptÃ© pour faciliter les calculs, par exemple :Î´t = 200â„¦
. Pour obtenir de beaux
e
âˆ’2
exemples, vous pourrez faire varier Fe entre 1.41 et 1.5 rad.s par pas de 0.005, ou entre
2.55 et 2.90. Vous pourrez obtenir un graphe comme montrÃ© dans la figure 2.1.

TP 3
Adsorption de particules sur une
surface
3.1

Surface homogÃ¨ne

Lâ€™exposition dâ€™une surface cristalline Ã  un gaz donne lieu Ã  des phÃ©nomÃ¨nes dâ€™adsorption : les particules du gaz sont piÃ©gÃ©es sur la surface du cristal. Ce phÃ©nomÃ¨ne a de
nombreuses applications, en particulier dans la rÃ©alisation de catalyseurs.
Pour modÃ©liser ce problÃ¨me, on fait les hypothÃ¨ses prÃ©liminaires suivantes :
â–· La surface cristalline est un carrÃ© de cÃ´tÃ© L.
â–· Les particules de gaz adsorbÃ©es sont modÃ©lisÃ©es par des disques de rayon R
avec R â‰ª L. Ces disques sont impÃ©nÃ©trables, câ€™est-Ã -dire que deux particules ne
peuvent pas se chevaucher. (Voir la figure 3.1a.)
â–· Une fois quâ€™une molÃ©cule a Ã©tÃ© adsorbÃ©e, elle ne bouge plus et ne quitte plus la
surface du cristal.
La simulation fonctionne ainsi : on part dâ€™une surface vide et, Ã  chaque pas de temps,
on essaye de rajouter une particule de gaz. La nouvelle particule arrive Ã  un endroit
alÃ©atoire si elle ne chevauche aucune particule dÃ©jÃ  prÃ©sente, on la garde, sinon rien

(a) Un exemple de particules sphÃ©riques
adsorbÃ©es alÃ©atoirement sur une surface.
La particule indiquÃ©e en gris est la derniÃ¨re
que lâ€™on a pu caser.

(b) Ã€ gauche : configuration interdite car les particules dÃ©bordent.
Ã€ droite : configuration valide. Les particules sont Ã  lâ€™extrÃªme
limite de la zone autorisÃ©e.

Figure 3.1 â€“ Surface homogÃ¨ne
27

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

ne se passe et le systÃ¨me nâ€™est pas modifiÃ©. On fait ainsi de nombreux essais jusquâ€™Ã  ce
que lâ€™on nâ€™arrive plus Ã  caser de nouvelles particules et on sâ€™intÃ©resse aux propriÃ©tÃ©s de
lâ€™Ã©tat final, en particulier au nombre de particules que lâ€™on a rÃ©ussi Ã  placer.
Une particule de gaz adsorbÃ©e doit-Ãªtre entiÃ¨rement contenue dans le carrÃ© (voir
figure 3.1b). Si on note (x, y) les coordonnÃ©es du centre de la particule, les valeurs
autorisÃ©es pour x et y en fonction de L et de R sont comprises dans lâ€™intervalle [R, L âˆ’ R].
Deux particules de coordonnÃ©es (x, y) et (xâ€² , yâ€² ) se chevauchent si leur distance est
infÃ©rieure Ã  2R, câ€™est Ã  dire :
q

(x âˆ’ xâ€² )2 + y âˆ’ yâ€² 2 < 2R
On peut donner une borne supÃ©rieure au nombre de particules de rayon R que lâ€™on
peut espÃ©rer caser sans chevauchement dans un carrÃ© de cÃ´tÃ© L, en prenant le rapport
entre la surface du carrÃ© et la surface dâ€™un cercle :
L2
Ï€R2
Sans chevauchement cette borne ne sera Ã©videmment jamais atteint, car il restera toujours des surfaces non-couvertes par des cercles. N_MAX sera utile pour rÃ©server Ã 
lâ€™avance un nombre suffisant de cases dans un tableau qui contiendra les coordonnÃ©es des cercles.
N_MAX =

1.

Ã‰crire un programme capable de simuler ce phÃ©nomÃ¨ne dâ€™adsorption. Le programme
doit essayer de placer successivement des particules dans le systÃ¨me jusquâ€™Ã  ce quâ€™il
y ait eu MAX_TRIES Ã©checs consÃ©cutifs, câ€™est-Ã -dire quâ€™aprÃ¨s MAX_TRIES dâ€™essais pour
placer la derniÃ¨re particule, il nâ€™a trouvÃ© aucun emplacement libre.
A la fin le programme devra afficher le nombre de particules placÃ©es ainsi que le
rapport entre la surface totale occupÃ©e par toutes les particules adsorbÃ©es et la surface
du carrÃ©. Les constantes L et R et MAX_TRIES seront des constantes et lâ€™on pourra prendre,
par exemple
L = 20.0
R = 0.4
MAX_TRIES = 1000

3.1.1

Conseils pour la mise en place du programme

Pour rÃ©aliser votre programme de la question prÃ©cÃ©dente, voici un certain nombre
de conseils sur les ingrÃ©dients Ã  mettre en place. Ces conseils sont lÃ  pour vous aider
Ã  une mise-en-place rapide et robuste par rapport aux â€œbugsâ€, mais vous Ãªtes libre de
les suivre ou pas et de faire vos propres choix des Ã©lÃ©ments de langage du python qui
sâ€™offrent ici.
3.1.1.1

La structure de donnÃ©es pour reprÃ©senter les cercles

Comme tous les cercles ont le mÃªme rayon R, la seule chose quâ€™il faut enregistrer
dans la mÃ©moire vive sont les coordonnÃ©es (x, y) des centres des cercles. Pour cela on
utilise ici deux tableaux numpy, un pour x et un pour y.
Lors de lâ€™adsorption les cercles seront ajoutÃ©s successivement Ã  la surface et devront alors Ã©galement Ãªtre enregistrÃ©s dans la mÃ©moire vive successivement. Comme
le processus est alÃ©atoire, il est impossible de savoir lâ€™avance combien de cercles seront

TP 3

29

enregistrÃ©s Ã  la fin dâ€™un remplissage du carrÃ©. On sait par contre que ce nombre nâ€™atteindra jamais N_MAX (voir plus haut). La structure de donnÃ©es adaptÃ©e ici est un â€œtableau
dynamiqueâ€, câ€™est Ã  dire un tableau qui peut changer de taille, comme ici croÃ®tre dâ€™une
case avec chaque ajout de cercle.
Ici le tableau dynamique est implÃ©mentÃ© avec un tableau statique de la bibliothÃ¨que
numpy de taille N_MAX et grÃ¢ce Ã  lâ€™utilisation dâ€™une variable n qui reprÃ©sente le nombre
de cercles dÃ©jÃ  prÃ©sents dans le systÃ¨me. Attention la taille dâ€™un tableau est un entier,
donc aussi N_MAX doit Ãªtre un entier.
On dÃ©finira, dans la fonction gÃ©rant lâ€™Ã©volution de notre systÃ¨me, trois variables
pour indiquer le nombre et la position des cercles adsorbÃ©es :
n = 0
# nombre de cercles dÃ©jÃ  prÃ©sents dans le systÃ¨me
x = np.empty(N_MAX)
# x[i] est lâ€™abscisse du i-Ã¨me cercle prÃ©sent
y = np.empty(N_MAX)
# y[i] est lâ€™ordonnÃ©e du i-Ã¨me cercle prÃ©sent
Ces variables seront ensuite transmises par argument aux diffÃ©rentes fonctions qui
les utilisent et/ou les mettent Ã  jour. Il faut noter que x[i] et y[i] ne sont dÃ©finis que
pour 0 â‰¤ i < n, donc pour parcourir les coordonnÃ©es des cercles dÃ©jÃ  adsorbÃ©s, on fait :
for i in range(n):
print(x[i], " ", y[i])
Au dÃ©part on a n=0, câ€™est cette variable qui dÃ©termine lâ€™emplacement des deux
tableaux oÃ¹ on doit ajouter un nouveau cercle : x[n] = x_new. AprÃ¨s chaque ajout n est
incrÃ©mentÃ© de un. Par construction n doit toujours rester bien infÃ©rieur Ã  N_MAX, sinon
il sâ€™agit dâ€™un bug. Pour vider la surface il suffit de faire n=0, pas besoin dâ€™initialiser les
valeurs des tableaux x et y ici.
3.1.1.2

Lâ€™organisation du code

Une bonne maniÃ¨re dâ€™Ã©crire le programme est dâ€™utiliser les fonctions suivantes :
â–· Une fonction coord(L, R) qui renvoie une valeur alÃ©atoire dans lâ€™intervalle autorisÃ© pour la coordonnÃ©e x ou y de la nouvelle particule quâ€™on essaye de placer. On
nâ€™a besoin dâ€™Ã©crire quâ€™une seule fonction coord(L, R) pour les deux coordonnÃ©es
x et y, comme il sâ€™agit dâ€™une surface carrÃ©e. Pour obtenir les deux nouvelles coordonnÃ©es x_new et y_new, on appellera coord(L, R) deux fois. On nâ€™utilise pas
ici rng.random() de numpy, mais np.random.rand() pour gÃ©nÃ©rer un nombre
alÃ©atoire rÃ©el entre 0 et 1. Cela Ã©vite de devoir passer un objet rng Ã  travers les
fonctions, mais aussi surtout dâ€™Ãªtre compatible avec numba, car rng.random() ne
fonctionne pas avec numba.
â–· Une fonction place_libre(n, x, y, x_new, y_new) qui vÃ©rifie si pour les nouvelles coordonnÃ©es x_new et y_new la place est libre, i.e. quâ€™il nâ€™y a pas de chevauchement avec les particules dÃ©jÃ  placÃ©es. Cette fonction retourne 0 si la place
nâ€™est pas libre et 1 si la place est libre. Quand il nâ€™y a pas encore de particules
adsorbÃ©es, n=0, la fonction doit bien sÃ»r retourner 1. Sinon pour n>0 elle doit
calculer dans une boucle toutes les distances entre le centre (x_new, y_new) de la
nouvelle particule et les centres des particules dÃ©jÃ  adsorbÃ©s. DÃ¨s quâ€™elle trouve
une distance infÃ©rieure Ã  2R, alors elle peut arrÃªter la boucle avec break.
â–· Une fonction remplissage(L, R, MAX_TRIES) qui gÃ¨re lâ€™Ã©volution du systÃ¨me
pour arriver Ã  un remplissage de la surface, jusquâ€™Ã  on a MAX_TRIES Ã©checs consÃ©cutifs. Elle renvoie le nombre de cercles adsorbÃ©s.

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

La fonction remplissage doit effectuer plusieurs tÃ¢ches :
def remplissage(L, R, MAX_TRIES):
... # crÃ©er tableaux numpy x et y pour coordonnÃ©es des cercles
n = 0
echecs = 0
while echecs < MAX_TRIES:
# tirage alÃ©atoire de coordonnÃ©es pour placer un nouveau cercle
x_new = coord(L, R)
y_new = coord(L, R)
# Test si lâ€™emplacement est libre:
libre = place_libre(n, x, y, x_new, y_new)
# Ajout de cercle si emplacement libre
if libre == 1:
... # ajout du nouveau cercle dans les tableaux numpy x et y
echecs = 0 # remettre le compteur Ã  zÃ©ro pour le prochain
,â†’ cercle
else:
echecs += 1 #incrÃ©menter Ã©checs
# fin boucle while
return x[:n], y[:n], n # retourner la partie des tableaux x et y
,â†’ qui a Ã©tÃ© remplie et le nombre de cercles adsorbÃ©s

3.1.2
2.

Analyse des rÃ©sultats

Appeler votre fonction remplissage avec les paramÃ¨tres donnÃ©s plus haut et visualiser
la configuration finale. Pour cela vous pouvez utiliser ce code 1 utilisant matplotlib :
import matplotlib.pylab as plt
import matplotlib # pour collections
# crÃ©e une liste dâ€™objets "Circle" de matplotlib avec les coordonnÃ©es
,â†’ extraites des tableaux x et y :
circles = [plt.Circle((xi,yi), radius=R, linewidth=0, color=â€™bâ€™) for
,â†’ xi,yi in zip(x,y)]
# crÃ©e une "collection" des cercles pour matplotlib, afin de tracer tous
,â†’ les cercles dâ€™un seul coup (câ€™est mieux au niveau temps de calcul):
c = matplotlib.collections.PatchCollection(circles)
plt.scatter(x,y,s=1) # nÃ©cessaire pour avoir les bons axes
plt.axis(â€™scaledâ€™) # pour un avoir un carrÃ© et pas un rectangle
plt.xlim(0, L)
plt.ylim(0, L)
plt.gca().add_collection(c) # tracer la collection de cercles
plt.savefig("graph02.pdf", bbox_inches=â€™tightâ€™)
plt.show()
VÃ©rifier bien quâ€™il nâ€™y a pas de chevauchement entre les cercles et quâ€™aucun cercle
dÃ©passe les bords du carrÃ©. Une fois que vous avez ainsi graphiquement vÃ©rifiÃ© que
1. trouvÃ© en partie ici : https://stackoverflow.com/questions/48172928/

TP 3

31

votre programme fonctionne bien, enlever pour la suite (dans un nouveau fichier
prog03.py) les lignes de code qui servent Ã  afficher les cercles.
3.

Modifier votre programme pour que lâ€™expÃ©rience soit faite M=20 fois, afin de calculer la
moyenne sur toutes ces expÃ©riences du nombre de particules adsorbÃ©es et de fraction de
la surface du carrÃ© quâ€™elles occupent. Ici bien sÃ»r on ne visualise pas les configurations
obtenues. Calculer aussi lâ€™Ã©cart-type de ces deux variables mesurÃ©es. Vous pouvez
utiliser ici les fonctions numpy np.mean() et np.std(). Comme ici on a deux grandeurs
A et B (ici n et Î·) qui sont reliÃ©es simplement par un facteur dâ€™Ã©chelle, il suffit de faire
le calcul de lâ€™Ã©cart-type pour une seule grandeur, puis dâ€™appliquer ce facteur dâ€™Ã©chelle
pour obtenir lâ€™Ã©cart-type de lâ€™autre grandeur :
Supposons que bi = k Â· ai , alors on obtient par simple insertion dans la formule de
lâ€™Ã©cart-type :
Ïƒ2B = k2 Â· Ïƒ2A
Pour vÃ©rifier vos rÃ©sultats, voici les valeurs approximatives quâ€™on devrait obtenir :
â–· La moyenne du nombre de particules adsorbÃ©es : < n >= 373 Â± 8, 4
â–· La moyenne de la fraction de surface : Î· =< n > Â·Ï€R2 /L2 = 0, 47 Â± 0, 01

4.

Avec une simple comparaison de valeurs sans faire un nouveau script python : Comment se comparent les valeurs obtenues Ã  la fraction quâ€™on pourrait idÃ©alement occuper
dâ€™une faÃ§on ordonnÃ©e ?
Voici deux exemples dâ€™empilement ordonnÃ© : lâ€™empilement carrÃ© et hexagonal
(voir figure 3.2). Pour lâ€™empilement carrÃ©
dâ€™une surface avec L = n Â· 2R la fraction
de surface occupÃ©e est simplement :
Ï€R2 Ï€
= = 0, 785
4R2
4
Lâ€™empilement hexagonal est lâ€™empilement le plus compact possible pour des
cercles de mÃªme taille, ce qui a Ã©tÃ© dÃ©montrÃ© par Joseph Louis Lagrange en 1773. La
fraction de surface occupÃ©e se calcule par Figure 3.2 â€“ Empilement ordonnÃ©, Ã  gauche :
exemple comme ceci :
empilement carrÃ©, Ã  droite : empilement
On suppose une surface rectangulaire hexagonal
L x H, avec L = n Â· 2R et m Ã©tant le nombre
de lignes de cercles. Le nombre de cercles
pour une surface
infinie (L â†’ âˆ) est alors Ã©gale Ã  m Â· n. La distance entre deux lignes est
âˆš
Ã©gale Ã  h = 3R = 1, 73R, comme les centres de trois cercles sont reliÃ©s par un triangle
Ã©quilatÃ©ral tel quâ€™on voit dans la figure 3.2, ce qui donne la relation R2 + h2 = 4R2 . Donc
la hauteur H de la surface peut Ãªtre exprimÃ© comme ceci, si on suppose un trÃ¨s grand
nombre de lignes m :
Î·=

âˆš
H = 2R + (m âˆ’ 1)h â‰ˆ m Â· h = m 3R
Au final on obtient pour lâ€™empilement hexagonal dâ€™une surface L x H trÃ¨s grande
par rapport Ã  R :
Î·=

m Â· n Â· Ï€R2
m Â· n Â· Ï€R2
Ï€
1 âˆš
=
= âˆš = Ï€ 3 = 0, 907
âˆš
LÂ·H
n Â· 2R Â· m 3R 2 3 6

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

Figure 3.4 â€“ ModÃ¨le dâ€™adsorption sur un rÃ©seau dâ€™atomes, ici en cercles pleins avec
croix. Les particules de gaz, ici en cercles avec tirets, peuvent soit sâ€™adsorber dans tous
les cas, si d < r_surf ou alors seulement avec une certaine probabilitÃ©, si d > r_surf.
Comme les atomes ont des coordonnÃ©es entiÃ¨res (0,1,2,...), il est trÃ¨s facile de trouver
lâ€™atome le plus proche Ã  partir des coordonnÃ©es de la particule de gaz : Il suffit de les
arrondir vers lâ€™entier le plus proche, ici par exemple : (2,6|0,4) => (3|0).

3.2

Surface structurÃ©e

On a jusque-lÃ  modÃ©lisÃ© ce problÃ¨me
en considÃ©rant la surface dâ€™adsorption
comme parfaitement homogÃ¨ne. En fait, il
y a des interactions entre les atomes de la
surface dâ€™adsorption et les particules du
gaz, et il se trouve que les particules du
gaz sâ€™adsorbent plus facilement Ã  proximitÃ© des atomes de la surface dâ€™adsorption.
Pour prendre le cas le plus simple,
on suppose que les atomes de la surface
dâ€™adoption sont organisÃ©s selon un rÃ©seau
cristallin carrÃ© de cÃ´tÃ© 1 (voir figure 3.3) :
il y a un atome de la surface en tous les
points de coordonnÃ©es (x, y) oÃ¹ x et y sont Figure 3.3 â€“ Surface dâ€™adsorption avec sa
des entiers compris entre 0 et L.
structure atomique, les atomes Ã©tant orgaDÃ©crire prÃ©cisÃ©ment ces interactions nisÃ©s en rÃ©seau carrÃ©.
est difficile, mais on obtient de bons rÃ©sultats avec le modÃ¨le simplifiÃ© suivant
(voir figure 3.4) :
â–· On suppose quâ€™il existe une distance caractÃ©ristique r_surf qui dÃ©crit la portÃ©e
de lâ€™interaction entre les atomes de la surface et les particules du gaz.
â–· Si une particule du gaz essaye de sâ€™adsorber Ã  une distance infÃ©rieure Ã  r_surf
de lâ€™un des atomes de la surface, lâ€™adsorption a toujours lieu.
â–· Si, au contraire, une particule du gaz essaye de sâ€™adsorber Ã  une distance supÃ©rieure Ã  r_surf de tous les atomes de la surface, lâ€™adsorption nâ€™a lieu quâ€™avec une
probabilitÃ© exp(âˆ’U/T) oÃ¹ U > 0 reprÃ©sente le â€œcoÃ»tâ€ Ã©nergÃ©tique Ã  se placer loin

TP 3

33
des particules de la surface et oÃ¹ T reprÃ©sente la tempÃ©rature. (Pour Ãªtre parfaitement prÃ©cis, T est en fait la tempÃ©rature en Kelvin multipliÃ©e par la constante de
Boltzmann kB .)

(Le modÃ¨le quâ€™on vient de dÃ©crire est une variante de â€œlâ€™algorithme de MÃ©tropolisâ€.
Lâ€™algorithme de MÃ©tropolis est trÃ¨s rÃ©pandu en physique et ailleurs. Voir lâ€™article original de Nicholas Metropolis et al. (1953) sur moodle.)
5.

Pour quelle valeur de T retrouve-t-on le modÃ¨le de la premiÃ¨re partie ? Comment
pourrait-on dÃ©crire en quelques mots le modÃ¨le obtenu en prenant T = 0 ?

3.2.1
6.

Mise en place du programme

Modifier votre programme pour prendre en compte les atomes de la surface et la
tempÃ©rature. La distance r_surf et lâ€™Ã©nergie U seront dÃ©finies par des constantes et
lâ€™on pourra prendre, par exemple,
r_surf = 0.05
U = 10.0

Il faudra
â–· DÃ©finir une fonction dist_latt(x_new, y_new) qui renvoie la distance du centre
de la particule de gaz de coordonnÃ©es (x_new, y_new) Ã  lâ€™atome le plus proche
de la surface dâ€™adsorption. On pourra utiliser la fonction np.rint de numpy qui
renvoie lâ€™entier le plus proche de son argument (voir figure 3.4 pourquoi cela est
utile).
â–· Modifier la fonction remplissage. Cette fonction prend dÃ©sormais en argument
la tempÃ©rature en plus : int remplissage(..., T) et doit implÃ©menter lâ€™algorithme dÃ©crit.
â–· Modifier votre programme pour simuler le modÃ¨le Ã  une tempÃ©rature donnÃ©e
(par exemple, T = 0 avec MAX_TRIES = 10000).
Quelques aides :
â–· Pour accepter lâ€™adsorption seulement avec la probabilitÃ© p = exp(âˆ’U/T) on pourra
utiliser np.random.rand() qui fournit un nombre (pseudo-)alÃ©atoire entre zÃ©ro
et un dâ€™une maniÃ¨re uniforme. La probabilitÃ© que la condition np.random.rand
() < p est vraie est alors Ã©gale Ã  p, si p âˆˆ [0, 1]. Comme U > 0 et T â‰¥ 0, on a
bien exp(âˆ’U/T) âˆˆ [0, 1] et on peut alors utiliser np.random.rand() < exp(-U/T)
comme condition pour accepter lâ€™adsorption pour les cas d > r_surf.
â–· Pour pouvoir inclure ici le cas T = 0, il faut transformer cette condition en : T*log
(np.random.rand()) < -U

3.2.2
7.

DÃ©pendance de la tempÃ©rature

Comme avant utiliser matplotlib pour visualiser sÃ©parÃ©ment les configurations finales
obtenues pour ces tempÃ©ratures T : 0, 1, 2, 5 et 10, (voir au dÃ©but de la section 3.1.2 avec
M=1). DÃ©crivez qualitativement ce que vous observez. Surtout pour des tempÃ©ratures
proche de zÃ©ro il faut utiliser MAX_TRIES = 10000 pour Ã©viter dâ€™avoir trop de trous Ã 
cause dâ€™une recherche pas assez profonde.

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

8.

Modifier votre programme pour faire M=100 simulations indÃ©pendantes pour chaque
tempÃ©rature entre 0 et 10 dâ€™un pas de âˆ†T = 0, 5, et tracer le graphe de la fraction
moyenne de la surface occupÃ©e en fonction de la tempÃ©rature. Utiliser ici un MAX_TRIES
= 10000. Vue la lenteur du calcul avec python de base, il est nÃ©cessaire dâ€™utiliser numba
ici, voir la section 3.4.1.

9.

En ayant analysÃ© les configurations avec matplotlib (question plus haut), comment
peut-on expliquer la courbe de la question prÃ©cÃ©dente ? Peut-on dÃ©finir une â€tempÃ©rature critiqueâ€ ? Avez vous une prÃ©diction thÃ©orique pour la valeur de la fraction Ã  basse
tempÃ©rature ?

3.3

Pour aller plus loin : MAX_TRIES et numba

Revenons sur la partie avec une surface homogÃ¨ne :
10.

RÃ©pÃ©ter pour plusieurs valeurs de MAX_TRIES le calcul de la fraction moyenne (taux) de
surface occupÃ©e par les atomes adsorbÃ©s ainsi que lâ€™Ã©cart-type. Augmenter MAX_TRIES
avec un facteur deux entre chaque simulation, comme ceci : 1000, 2000, 4000, ..., 32000.
Utiliser M=20 rÃ©pÃ©titions seulement pour limiter le temps de calcul. Tracer la fraction
moyenne de surface occupÃ©e en fonction de MAX_TRIES en Ã©chelle semi-log. Pour
afficher Ã©galement lâ€™Ã©cart-type sous forme de barres dâ€™erreurs, vous pouvez utiliser
errorbar de matplotlib Ã  la place de la commande plot :
plt.errorbar(max_tries, moy_fracSurface, yerr = ecart_fracSurface)
Commentez le graphe.

11.

AccÃ©lÃ©rer lâ€™exÃ©cution de votre code avec numba, voir section 3.4.1. Essayer dâ€™Ã©tendre la
courbe jusquâ€™Ã  MAX_TRIES = 512.000 et avec M=100 rÃ©pÃ©titions. Commentez le nouveau
graphe.

3.4

Annexe

3.4.1

numba

Voir aussi les exercices de TD sur numba sur moodle, il sâ€™agit dâ€™un tutoriel pour apprendre
Ã  utiliser numba. Puis quelques points importants sont notÃ©s Ã  la fin du TP1, section 1.3.
Pour que le temps de calcul ne rend pas impossible la rÃ©alisation de certains exercices, lâ€™utilisation de numba devient incontournable ici, car on peut obtenir avec numba
une accÃ©lÃ©ration de trois ordres de grandeurs ici. Pour pouvoir utiliser numba, il faut
utiliser np.random.rand() et non rng.random() pour gÃ©nÃ©rer un nombre alÃ©atoire rÃ©el
entre 0 et 1, comme indiquÃ© au dÃ©but de ce TP. De plus il faut faire attention que N_MAX
est un entier, car comme le python de base, numba nâ€™accepte pas np.empty(N_MAX)
avec une valeur rÃ©elle pour N_MAX. Cela produit un message dâ€™erreur de numba, qui
sont en gÃ©nÃ©ral plus difficile Ã  comprendre que les messages dâ€™erreurs de python de
base.
Ici on ajoute devant (ligne au-dessus du def ...) la dÃ©finition des trois fonctions
coord, place_libre et remplissage lâ€™indication Ã  numba de compiler ces fonctions :
from numba import njit
@njit
def coord(L, R) :

TP 3

35

...
@njit
def place_libre(n, x, y, x_new, y_new):
...
@njit
def remplissage(L, R, MAX_TRIES) :
...

3.4.2

Liens sur lâ€™empilement compact

En sciences on peut aussi faire des expÃ©riences amusantes et les publier dans un
journal important comme â€œScienceâ€. Comme cette expÃ©rience avec laquelle les chercheurs ont dÃ©montrÃ©s que lâ€™empilement au hasard des bonbons M&Ms dans une sphÃ¨re
donne un empilement presque aussi dense que lâ€™empilement ordonnÃ© le plus compact
de sphÃ¨res de taille Ã©gale (empilement cubique Ã  faces centrÃ©es ou empilement hexagonal compact) :
http://www.ncbi.nlm.nih.gov/pubmed/14963324
(voir aussi sur moodle pour avoir lâ€™article)
Cette bonne performance des bonbons M&Ms est dÃ» Ã  leur forme ellipsoÃ¯dale, qui
permet un meilleur empilement.

TP 4
Valeurs propres et vecteurs propres :
RÃ©solution de lâ€™Ã©quation de
SchrÃ¶dinger par un calcul de
diffÃ©rences finies
Lâ€™Ã©quation de SchrÃ¶dinger HÏˆ = EÏˆ est lâ€™Ã©quation maÃ®tresse de la mÃ©canique quantique : rÃ©soudre un problÃ¨me de physique quantique revient en gÃ©nÃ©ral Ã  rÃ©soudre
cette Ã©quation dans le cas considÃ©rÃ©. Malheureusement, mÃªme dans les cas simples, on
se heurte Ã  des problÃ¨mes techniques souvent ardus quand on cherche Ã  le faire ; fort
souvent mÃªme, il nâ€™y a pas de solution analytique du tout ! Dans le prÃ©sent exercice, on
Ã©tudiera une mÃ©thode simple, peu exigeante sur le plan de la programmation (il sâ€™agit
essentiellement de faire appel Ã  un sous-programme de bibliothÃ¨que dÃ©jÃ  existant) pour
tenter de rÃ©soudre numÃ©riquement des problÃ¨mes dont la solution est connue (puits
infini, oscillateur harmonique) afin de contrÃ´ler la mÃ©thode, puis dans des cas oÃ¹ la
solution nâ€™est pas connue. Ce sera aussi lâ€™occasion de se familiariser Ã  peu de frais avec
cet objet Ã©trange quâ€™est la fonction dâ€™onde Ïˆ.
On se restreint ici Ã  lâ€™Ã©quation de SchrÃ¶dinger stationnaire (ou non-dÃ©pendante du
temps) Ã  une particule et Ã  une dimension. Il sâ€™agit donc de chercher les Ã©tats propres
dâ€™une particule dans un potentiel stationnaire 1 .
Dans ces conditions, lâ€™Ã©quation de SchrÃ¶dinger sâ€™Ã©crit :
â„2 d2 Ïˆ(x)
+ V(x) Ïˆ(x) = E Ïˆ(x)
(4.1)
2m dx2
oÃ¹ V et Ïˆ sont des fonctions de lâ€™abscisse x, V(x) est lâ€™Ã©nergie potentielle de la
particule au point dâ€™abscisse x, Ïˆ(x) la fonction dâ€™onde qui dÃ©crit lâ€™Ã©tat de la particule et
E lâ€™Ã©nergie associÃ©e Ã  cet Ã©tat ; m est la masse de la particule et â„ la constante de Planck.
RÃ©soudre lâ€™Ã©quation (4.1) revient Ã  trouver les fonctions dâ€™ondes Ïˆ(x) et les Ã©nergies E
pour lesquelles lâ€™Ã©quation est vÃ©rifiÃ©e : il sâ€™agit dâ€™une Ã©quation diffÃ©rentielle du second
ordre dont on connaÃ®t les solutions analytiques dans certains cas (V = Cst, V = 12 kx2 ,
. . .), mais reste insoluble dans bien des cas dâ€™oÃ¹ la recherche de solutions numÃ©riques.
Afin de simplifier les notations, on utilisera un systÃ¨me dâ€™unitÃ©s ad hoc dans lequel
â„2
= 1, donc lâ€™Ã©quation (4.1) devient :
2m
d2 Ïˆ(x)
âˆ’
+ V(x) Ïˆ(x) = E Ïˆ(x)
(4.2)
dx2
âˆ’

1. voir le cours de physique quantique.

37

Sorbonne UniversitÃ©

3P126 - TP phys. num.

Ïˆ(x)

V4
V3

V(x)

Ïˆi+1 âˆ’ Ïˆi

V2

2025-2026

dÏˆ
dx

Î´
Î´
dÏˆ
dÏˆ
x+ x âˆ’
xâˆ’ x
dx ( i 2 ) dx ( i 2 )
Î´x

Î´x

V1

Ïˆi âˆ’ Ïˆiâˆ’1
Î´x

V0
x0

x1

x2

x3

x4

x

xiâˆ’1

xi âˆ’

Î´x
2

xi

xi +

Î´x
2

xi+1 x

xiâˆ’1

xi âˆ’

Î´x
2

xi

xi +

Î´x
2

xi+1 x

Figure 4.1 â€“ Gauche : Illustration de la discrÃ©tisation de x ainsi que des consÃ©quences
pour le potentiel V et la fonction dâ€™onde Ïˆ. Centre : La dÃ©rivÃ©e premiÃ¨re de Ïˆ est
approchÃ©e Ã  xi Â± Î´x /2. Droite : La dÃ©rivÃ©e seconde de Ïˆ est approchÃ©e Ã  xi .

4.1

La mÃ©thode des diffÃ©rences finies.

Le problÃ¨me est lÃ©gÃ¨rement diffÃ©rent de celui de la rÃ©solution dâ€™une (ou plusieurs)
Ã©quation(s) du mouvement oÃ¹ lâ€™on calcule de proche en proche les valeurs que prend la
ou les fonctions recherchÃ©es : ici, on veut simultanÃ©ment toutes les valeurs de Ïˆ(x) et de
surcroÃ®t E est aussi une inconnue. Les mÃ©thodes de type Runge-Kutta ne conviennent
donc pas, il faut en trouver dâ€™autres.
La mÃ©thode des diffÃ©rences finies en est une possible. Elle consiste en une discrÃ©tisation du problÃ¨me, câ€™est-Ã -dire que lâ€™on fait lâ€™approximation de remplacer la variable
continue x par une variable discrÃ¨te xi :
xi = âˆ’L/2 + i Â· Î´x , i âˆˆ [0, n âˆ’ 1]
oÃ¹ i est un indice entier. La droite infinie est Ã©videmment remplacÃ©e par un segment fini
de longueur L = (n âˆ’ 1)Î´x , centrÃ© autour de zÃ©ro, on couvre alors lâ€™intervalle [âˆ’L/2, L/2].
Cela entraÃ®ne que Î´ doit Ãªtre â€œpetitâ€, câ€™est-Ã -dire sensiblement plus petit quâ€™une
distance â€œtypiqueâ€ sur laquelle la fonction dâ€™onde varie sensiblement. Par ailleurs, L
doit Ãªtre â€œpresqueâ€ infini, soit, plus grand que le domaine dans lequel la particule peut
se dÃ©placer. Autrement dit, n doit Ãªtre â€œgrandâ€.
Notre objectif est maintenant de discrÃ©tiser lâ€™Ã©quation de SchrÃ¶dinger, câ€™est-Ã -dire
en particulier la fonction dâ€™onde ainsi que sa dÃ©rivÃ©e seconde. On pose :
Ïˆi = Ïˆ(xi )
Vi = V(xi )
pour la fonction dâ€™onde et le potentiel discrÃ©tisÃ©s. Pour la dÃ©rivÃ©e premiÃ¨re de Ïˆ, prise
un demi-intervalle au delÃ  de xi , on peut trouver une expression approchÃ©e :
 Ïˆ âˆ’Ïˆ
dÏˆ 
Î´x
i+1
i
xi +
âˆ¼
dx
2
Î´x
De mÃªme on trouve pour la dÃ©rivÃ©e prise un demi-intervalle en deÃ§Ã  de xi :
 Ïˆ âˆ’Ïˆ
dÏˆ 
Î´x
i
iâˆ’1
xi âˆ’
âˆ¼
dx
2
Î´x
En utilisant ces expressions, nous pouvons ensuite en dÃ©duire une expression approchÃ©e pour la dÃ©rivÃ©e seconde de Ïˆ prise en xi :

TP 4

39

dÏˆ
(xi ) âˆ¼
dx2
2

dÏˆ
dx


 dÏˆ 

xi + Î´2x âˆ’ dx xi âˆ’ Î´2x
Î´x

=

Ïˆi+1 âˆ’ 2Ïˆi + Ïˆiâˆ’1
Î´2x

Muni de ces expressions approchÃ©es, nous pouvons Ã©tablir une forme discrÃ©tisÃ©e de
lâ€™Ã©quation de SchrÃ¶dinger :
âˆ’

Ïˆi+1 âˆ’ 2Ïˆi + Ïˆiâˆ’1
Î´2x

+ Vi Ïˆi = EÏˆi

(4.3)

Dans la suite on va Ã©tudier trois problÃ¨mes qui correspondent Ã  des potentiels V(x)
diffÃ©rents :
1. le puits carrÃ© infini : Il suffit de fixer la valeur du potentiel Ã  zÃ©ro partout sur
lâ€™intervalle, V(x) = 0.
q
2. le potentiel harmonique : V(x) = m2 Ï‰2 x2 . Ici on prendra Ï‰ = m1 (voir ci-dessous).
3. un double puits, paramÃ©trÃ© par V(x) = a(x âˆ’ r1 )(x âˆ’ r2 )(x âˆ’ r3 )(x âˆ’ r4 ), soit un
polynÃ´me de degrÃ© 4 dont les racines sont r1 , r2 , r3 , r4 .
1.

Ã‰crire trois fonctions (une par problÃ¨me) qui rendent la valeur V(x). Lorsquâ€™on voudra
ensuite changer la forme du potentiel il suffira de modifier lâ€™appel de la fonction, Ã 
lâ€™exclusion du reste du programme. Ces fonctions sont alors de cette forme :
def potentiel_puits(x):
return ...
â‡’ Rendre un seul script python qui contient les rÃ©sultats des Ã©xercices 1 et 2.

2.

DÃ©finir un intervalle [âˆ’L/2, L/2], le diviser en n segments de longueur Î´x et remplir les
tableaux x (contenant les xi ) et V (contenant les valeurs de potentiel Vi ). On peut utiliser
des tableaux numpy classiques (structure de donnÃ©es ndarray). Tracer ensuite les trois
potentiels dÃ©finis dans lâ€™exercise prÃ©cÃ©dent dans une seule figure. Choisir L = 5, n = 100
et a = 1, r1 = âˆ’r4 = 2 , r2 = âˆ’r3 = 0.5.
â‡’ Rendre une seule figure avec lâ€™inscription des axes et la lÃ©gende.

4.2

Valeurs propres-vecteurs propres.

On considÃ¨re maintenant que la fonction dâ€™onde discrÃ©tisÃ©e est un vecteur :
ï£«
ï£¶
ï£¬ï£¬ Ïˆ0 ï£·ï£·
ï£¬ï£¬
ï£·
ï£¬ï£¬ Ïˆ1 ï£·ï£·ï£·
ï£¬ï£¬ . ï£·ï£·
ï£¬ï£¬ . ï£·ï£·
ï£¬ï£¬ . ï£·ï£·
ï£¬
ï£·
Ïˆ = ï£¬ï£¬ï£¬ï£¬ Ïˆi ï£·ï£·ï£·ï£·
ï£¬ï£¬ . ï£·ï£·
ï£¬ï£¬ .. ï£·ï£·
ï£¬ï£¬
ï£·ï£·
ï£·
ï£¬ï£¬ Ïˆ
ï£¬ï£¬ nâˆ’2 ï£·ï£·ï£·
ï£­
ï£¸
Ïˆnâˆ’1
On peuut Ã©crire lâ€™expression de la matrice n Ã— n notÃ©e H telle que lâ€™Ã©quation de
SchrÃ¶dinger discrÃ©tisÃ©e sâ€™Ã©crive maintenant sous forme matricielle :
HÏˆ = EÏˆ

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

On appellera H lâ€™Hamiltonien discrÃ©tisÃ© : ce nâ€™est plus un opÃ©rateur comme dans
lâ€™Ã©quation (4.1), mais une matrice 2 .
Autrement dit, lâ€™Ã©quation de SchrÃ¶dinger discrÃ©tisÃ©e sâ€™Ã©crit pour tous les Ïˆi :
nâˆ’1
X

Hi j Â· Ïˆ j = E Â· Ïˆi

(4.4)

j=0

Si on regroupe lâ€™Ã©quation 4.3 par les diffÃ©rents Ïˆi , on obtient :

âˆ’

Ïˆi+1 âˆ’ 2Ïˆi + Ïˆiâˆ’1
Î´2x

+ Vi Ïˆi = EÏˆi

!
1
1
2
âˆ’ 2 Ïˆiâˆ’1 + 2 + Vi Ïˆi âˆ’ 2 Ïˆi+1 = EÏˆi
Î´x
Î´x
Î´x

(4.5)

En comparant lâ€™Ã©quation 4.4 avec lâ€™Ã©quation 4.5 on obtient :
2
+ Vi
Î´2x
1
Hi(iâˆ’1) = âˆ’ 2
Î´x
1
Hi(i+1) = âˆ’ 2
Î´x
Hii =

Donc concrÃ¨tement, la matrice H a cette forme :
ï£« 2
âˆ’ Î´12
0
0
0
ï£¬ï£¬ Î´2x + V0
x
ï£¬ï£¬
1
1
2
ï£¬ï£¬ âˆ’ 2
+ V1
âˆ’ Î´2
0
0
ï£¬ï£¬
Î´x
Î´2x
x
ï£¬ï£¬
2
0
âˆ’ Î´12
+ V2
âˆ’ Î´12
0
ï£¬ï£¬
Î´2x
ï£¬ï£¬
x
x
ï£¬ï£¬ . . .
...
...
...
...
H = ï£¬ï£¬ï£¬ï£¬
1
2
0
âˆ’ Î´2
âˆ’ Î´12
ï£¬ï£¬ . . .
2 + Vi
Î´
x
x
x
ï£¬ï£¬
ï£¬ï£¬ . . .
.
.
.
.
.
.
.
.
.
.
.
.
ï£¬ï£¬
ï£¬ï£¬
0
...
0
0
âˆ’ Î´12
ï£¬ï£¬
x
ï£¬ï£­
0
...
0
0
0

...
...
...
...
0
...
2
+
Vnâˆ’2
Î´2x
âˆ’ Î´12
x

ï£¶
0
ï£·ï£·
ï£·ï£·
ï£·ï£·
0
ï£·ï£·
ï£·ï£·
0
ï£·ï£·
ï£·ï£·
ï£·ï£·
...
ï£·ï£·
ï£·ï£·
...
ï£·ï£·
ï£·ï£·
ï£·ï£·
...
ï£·ï£·
1
ï£·ï£·
âˆ’ Î´2
ï£·ï£·
x
ï£·
2
+ Vnâˆ’1 ï£¸
Î´2
x

Câ€™est une matrice tridiagonale symÃ©trique.
Les extrÃ©mitÃ©s de lâ€™intervalle, x0 et xnâˆ’1 , doivent faire lâ€™objet dâ€™une attention particuliÃ¨re. On fera lâ€™approximation supplÃ©mentaire que Ïˆâˆ’1 = Ïˆn = 0, câ€™est-Ã -dire que la
fonction dâ€™onde Â« Ã  lâ€™infini Â» est nulle : En i = 0 on nâ€™a pas le terme en Ïˆiâˆ’1 et en i = n âˆ’ 1,
le terme Ïˆi+1 est absent. Cela revient Ã  postuler que la fonction dâ€™onde est nulle aux
deux extrÃ©mitÃ©s de lâ€™intervalle fini considÃ©rÃ©. La consÃ©quence en est que la particule
ne doit pas sâ€™aventurer vers les extrÃ©mitÃ©s de lâ€™intervalle et que donc lâ€™extension de sa
fonction dâ€™onde doit rester Ã  peu prÃ¨s centrÃ©e et petite devant la taille de lâ€™intervalle.
2. Pour mieux comprendre le lien entre la matrice H et lâ€™Ã©quation (4.1), il est utile dâ€™Ã©crire lâ€™opÃ©rateur
PÌ‚2
hamiltonien en reprÃ©sentation de position : Lâ€™opÃ©rateur hamiltonien est dÃ©fini comme HÌ‚ = 2m
+ V(XÌ‚)
avec lâ€™opÃ©rateur impulsion PÌ‚ et lâ€™opÃ©rateur de position XÌ‚ . On fait alors le choix de la "reprÃ©sentation
de position |xâŸ©" dÃ©finie par XÌ‚|xâŸ© = x|xâŸ© oÃ¹ x est maintenant une variable. Dans cette reprÃ©sentation on
dÏˆ(x)
obtient âŸ¨x|P|ÏˆâŸ© = âˆ’iâ„ dx et âŸ¨x|V(X)|ÏˆâŸ© = V(x)Ïˆ(x) oÃ¹ âŸ¨x|ÏˆâŸ© = Ïˆ(x) est la fonction dâ€™onde.

TP 4
3.

41

Quel sens physique cela peut-il avoir ? Quelle est la consÃ©quence pour le potentiel effectif quâ€™on simule avec cette approche ?
Le problÃ¨me mathÃ©matique Ã  rÃ©soudre est maintenant devenu une Ã©quation aux
valeurs propres : les valeurs que peut prendre E sont les valeurs propres de la matrice
H et le vecteur Ïˆ est le vecteur propre asssociÃ© Ã  chaque valeur propre. Comme la
matrice est n Ã— n, il doit y avoir n valeurs propres et n vecteurs propres solution de
lâ€™Ã©quation de SchrÃ¶dinger discrÃ©tisÃ©e.

4.3

Mise en Å“uvre numÃ©rique.

Il nâ€™est pas question dâ€™Ã©crire une fonction capable de rÃ©soudre un problÃ¨me aux
valeurs propres ! Il existe de nombreuses bibliothÃ¨ques de programmes dÃ©jÃ  Ã©crits et
testÃ©s : ils sont fiables et efficaces, il est inutile de rÃ©inventer la roue ! On utilisera ici
la bibliothÃ¨que scipy.linalg, qui est une collection dâ€™outils pour traiter les problÃ¨mes
dâ€™algÃ¨bre linÃ©aire. Ici, nous utiliserons la routine de diagonalisation eigh_tridiagonal,
qui diagonalise les matrices symÃ©triques tridiagonales :
import numpy as np
from scipy.linalg import eigh_tridiagonal
n = 100
# dimension de la matrice
d = np.zeros(n)
# diagonale principale de la matrice
e = np.zeros(n-1) # diagonale juste au-dessus
...
# remplissage de d,e
w, v = eigh_tridiagonal(d,e)
La fonction eigh_tridiagonal(d,e) prend la diagonale d et les Ã©lÃ©ments au-dessus
de la diagonale e dâ€™une matrice tridiagonale symÃ©trique comme argument, puis elle
diagonalise la matrice et renvoie les valeurs propres dans le vecteur w et les vecteurs
propres dans la matrice v. Plus prÃ©cisÃ©ment, le vecteur w contient les valeurs propres,
par ordre croissant, chacune Ã©tant rÃ©pÃ©tÃ©e en fonction de sa multiplicitÃ©.
Il ne reste plus quâ€™Ã  remplir la diagonale d et la sous-diagonale e qui reprÃ©sentent
H en forme discrÃ¨te. La taille du Hamiltonien n Ã— n dÃ©pend du nombre dâ€™Ã©lÃ©ments du
vecteur Ïˆ. A noter quâ€™au lieu dâ€™initialiser et de remplir ensuite les vecteurs d et e, on
peut directement dÃ©finir ces vecteurs correctement dÃ¨s le dÃ©part.
4.

CrÃ©er les tableaux 1D d , e et les remplir avec les Ã©lÃ©ments diagonaux et sous-diagonaux
de H. Utiliser ici le potentiel du puits carrÃ© infini.
â‡’ Rendre un seul script python qui contient les rÃ©sultats des Ã©xercices 4 et 5.

5.

Rechercher les valeurs propres et les vecteurs propres en utilisant la routine de diagonalisation eigh_tridiagonal.

4.4

Ã‰tude numÃ©rique.

Nota bene : Lors de ce TP seront gÃ©nÃ©rÃ©s beaucoup de fichiers *.pdf diffÃ©rents en
fonction du potentiel. Pour garder une trace de quel fichier correspond Ã  quoi, il est utile
de directement inclure les informations saliants dans le nom de fichier, par exemple
q6_puits_valeurs_n100_L5.pdf correspondrait aux valeurs propres de la question 6
pour un puits de potentiel avec n = 100, L = 5.

Sorbonne UniversitÃ©

4.4.1

3P126 - TP phys. num.

2025-2026

Puits carrÃ© infini.

Rappels thÃ©oriques 3 :
Si on considÃ¨re une particule dans un puits carrÃ© infini de largeur L, les fonctions
dâ€™onde solutions de lâ€™Ã©quation de SchrÃ¶dinger indÃ©pendante du temps sont nulles en
dehors du puits et ont la forme suivante dans le puits
r
(p + 1)Ï€(x + L2 )
2
sin
Ïˆtheo
(x)
=
p
L
L
Les Ã©nergies de ces Ã©tats sâ€™Ã©crivent :
=
Etheo
p

â„2 Ï€(p + 1)
2m
L

!2

â„2
= 1.
2m
Essayer votre programme avec n = 100 et L = 5, afin de comparer le rÃ©sultat obtenu
avec le rÃ©sultat thÃ©orique : Tracer les Ã©nergies propres Ep (qui se trouvent dans le vecteur
w) en fonction de p avec, sur le mÃªme graphe, la courbe thÃ©orique Etheo
p . VÃ©rifier lâ€™accord
avec la courbe thÃ©orique et discuter le rÃ©sultat.
â‡’ Rendre une seule figure avec les deux courbes.

Rappel : on choisit ici
6.

Ensuite, on souhaite comparer Ã©galement les fonctions dâ€™onde. On remarquera que
les fonctions dâ€™ondes calculÃ©es ne sont pas normalisÃ©es comme les fonctions dâ€™ondes
thÃ©oriques avec
Z
Ïˆ2 dx = 1
On peut le faire, si souhaitÃ©, avec cette fonction par exemple sur la matrice v des
vecteurs propres :
def normalize(m,delta_x):
m /= np.linalg.norm(m, axis=0)
m /= np.sqrt(delta_x)
return m

# normaliser les colonnes
# diviser par 1/sqrt(dx)

Les colonnes de v sont dÃ©jÃ  normalisÃ©es, mais pour Ãªtre sÃ»rsâˆšnous le faisons encore
dans la fonction nomalize. La multiplication avec le scalaire 1/ Î´x peut Ãªtre effectuÃ©e
pour tous les Ã©lÃ©ments de la matrice avec une seule commande.
7.

DÃ©finir et utiliser la fonction nomalize. Tracer ensuite les premiÃ¨res fonctions dâ€™onde
(p âˆˆ [0, 2]) obtenues par votre programme : Pour cela tracer sur le mÃªme graphe
les premiÃ¨res (p âˆˆ [0, 2]) fonctions dâ€™onde au carrÃ©, dÃ©calÃ©es verticalement dâ€™une valeur
proportionnelle Ã  leur Ã©nergie Ep . Attention Ã  ne pas confondre les lignes et les colonnes
- les vecteurs propres se trouvent dans les colonnes de la matrice v. Discuter le rÃ©sulat
qualitativement eu Ã©gard des rÃ©sultats attendus pour un puits carrÃ© infini.
â‡’ Rendre une seule figure avec les trois courbes dÃ©calÃ©es ainsi que un script python
qui contient votre programme complet. Pour la suite, il nâ€™est pas demandÃ© dâ€™imprimer
Ã  nouveau le script python.
3. Reportez-vous au cours de physique quantique.

TP 4
8.

43

Comparer lâ€™accord entre les fonctions dâ€™onde numÃ©riques et thÃ©oriques pour p = 1 et
un ordre plus Ã©levÃ© dans le domaine oÃ¹ lâ€™accord pour Ep nâ€™est pas bon, par exemple
p = 55. Attention Ã  ne pas mÃ©langer les fonctions dâ€™onde avec leurs valeurs au carrÃ©.
Faites votre diagnostic.
â‡’ Rendre deux figures avec lâ€™inscription des axes et la lÃ©gende - un graphe par valeur
de p. Faites attention Ã  rendre des figures avec des courbes lisibles. Si nÃ©cessaire, ajuster
lâ€™ordonnÃ©e ou modifier lâ€™Ã©chelle de la courbe.

4.4.2

Potentiel harmonique.

Rappels thÃ©oriques :
Le deuxiÃ¨me cas dont la solution est connue est le potentiel harmonique 4 :
r
k
1 2 m 2 2
V(x) = kx = Ï‰ x , Ï‰ =
2
2
m
Les Ã©nergies propres sâ€™Ã©crivent maintenant :


1
Etheo
=
p
+
â„Ï‰,
p
2

p = 0, 1, 2, 3, . . .

Lâ€™Ã©tat fondamental, pour p = 0 a donc une Ã©nergie E0 = â„Ï‰/2.
9.

Modifier votre
programme
âˆš pour Ã©tudier le potentiel harmonique : on prendra k = 1,
âˆš âˆš
soit â„Ï‰ = 2m k/m = 2. Il sâ€™agit de la forme de potentiel que vous avez dÃ©jÃ  mise
en Å“uvre dans lâ€™exercice 1. Pour rappel : Il suffit de changer lâ€™appel de la fonction du
potentiel.
RÃ©pÃ©ter les opÃ©rations de lâ€™exercice 6 avec n = 100 et L = 5 : tracer les Ã©nergies propres
numÃ©riques Ep avec la courbe thÃ©orique Etheo
p . Commenter le rÃ©sultat.
â‡’ Rendre une seule figure avec deux courbes.

10.

Refaire le mÃªme calcul, toujours avec n = 100 mais cette fois-ci avec L = 20. Commenter
sur lâ€™impact de Î´x et n par rapport aux rÃ©sultats obtenus - diagnostic.
â‡’ Rendre une seule figure avec deux courbes.

11.

Tracer sur le mÃªme graphe le potentiel V(x) ainsi que les premiÃ¨res (p âˆˆ [0, 2]) fonctions
dâ€™onde au carrÃ© (numÃ©riques), dÃ©calÃ©es verticalement dâ€™une valeur Ã©gale Ã  leur Ã©nergie
Ep . (On pourra multiplier lâ€™amplitude des fonctions dâ€™onde, avant dÃ©calage de Ep ,
par un facteur pour Ã©viter leur chevauchement et ainsi rendre le graphe bien lisible).
Quâ€™observe-t-on quand Ã  la "largeur" de la fonction dâ€™onde ? Commenter.
â‡’ Rendre une seule figure avec quatre courbes - le potentiel ainsi que les trois fonctions
dâ€™onde au carrÃ©.

4.4.3

Double puits.

Lâ€™intÃ©rÃªt de cet exercice nâ€™est bien sÃ»r pas de chercher Ã  rÃ©soudre un problÃ¨me dont
la solution analytique est connue (comme le puits infini ou lâ€™oscillateur harmonique).
Cela permet juste de tester le programme que lâ€™on a Ã©crit et dâ€™illustrer le cours de
physique quantique.
4. Se reporter de nouveau au cours de physique quantique.

Sorbonne UniversitÃ©

3P126 - TP phys. num.

2025-2026

Toutefois, le mÃªme programme, Ã  trÃ¨s peu de choses prÃ¨s, permet de rÃ©soudre des
problÃ¨mes sensiblement plus compliquÃ©s, pour lesquels les solutions analytiques sont
pour lâ€™essentiel inaccessibles. On remplace le potentiel harmonique maintenant par :
V(x) = a(x âˆ’ r1 )(x âˆ’ r2 )(x âˆ’ r3 )(x âˆ’ r4 )
soit un polynÃ´me de degrÃ© 4, dont les racines sont r1 , r2 , r3 , r4 .
Selon le paramÃ¨trage du potentiel, il permet de simuler un double puits symÃ©trique ou
dissymÃ©trique. Pour la suite, prenez n = 1000 et L = 20.
12.

Comme prÃ©cÃ©demment, tracer sur un seul graphe les solutions obtenues des premiers
Ã©tats pour a = 1 et r1 = âˆ’2, r2 = âˆ’0.5, r3 = 0.5, r4 = 2, ainsi que le potentiel V(x). Câ€™est le
paramÃ¨trage de votre troisiÃ¨me fonction de lâ€™Ã©xercice 1 et correspond Ã  un double puits
symÃ©trique. Quel est le sens physique dâ€™un tel potentiel, quelles appliquations pourraitil avoir ? Commenter ensuite sur la forme des premiers Ã©tats propres du systÃ¨me.
Retrouvez-vous dans vos rÃ©sultats des effets que vous connaissez dÃ©jÃ , par exemple de
la physique molÃ©culaire ?
â‡’ Rendre une seule figure avec plusieurs courbes. VÃ©rifier que toutes les courbes sont
bien lisibles, quâ€™elles sont dÃ©placÃ©es proportionellement Ã  leurs Ã©nergies et quâ€™elles sont
Ã©tiquetÃ©es dans la lÃ©gende.

4.4.4

Pour aller plus loin : Double puits particuliers

13.

Tracer les solutions obtenues pour a = 400 et r1 = âˆ’2, r2 = âˆ’0.5, r3 = 0.5, r4 = 2
(double puits symÃ©trique plus profond). Commenter et, bien sÃ»r, comparer avec le cas
prÃ©cÃ©dent.

14.

Tracer maintenant les solutions obtenues pour a = 1 et r1 = âˆ’2, r2 = âˆ’0.5, r3 = 0,
r4 = 2, ainsi que le potentiel V(x). Câ€™est un potentiel correspondant Ã  un double puits
dissymÃ©trique. Commenter et, bien sÃ»r, comparer avec le double puits symÃ©trique avec
a = 1.
â‡’ Comme prÃ©cÃ©demment, rendre une seule figure avec plusieurs courbes.

4.5

Conclusion.

On a, sans coup fÃ©rir, diagonalisÃ© des matrices (1000 Ã— 1000) en comptant sur la
capacitÃ© de calcul de lâ€™ordinateur : câ€™est ce quâ€™on appelle un calcul par Â« force brute Â».
Compte tenu du temps que cela prend, que pensez-vous dâ€™un problÃ¨me tridimensionnel
Ã  un Ã©lectron (et donc une matrice (10003 Ã— 10003 ) Ã  traiter), et a fortiori dâ€™un problÃ¨me
tridimensionnel Ã  quelques centaines dâ€™Ã©lectron (en gros, une molÃ©cule simple. . .) ?

